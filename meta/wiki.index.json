{
  "ownKey": "wiki",
  "childrenPages": {"wiki": {
    "ownKey": "wiki",
    "childrenPages": {
      "custom-assertions": {
        "ownKey": "custom-assertions",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "custom-assertions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/custom-assertions"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "additional-modules",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/additional-modules"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "grouping-with-and",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/grouping-with-and"
          },
          "description": "",
          "title": "Custom Assertions",
          "content": "<h1 id=\"custom-assertions\">Custom Assertions<\/h1>\n<p>One of the aims of Strikt is that implementing your own assertions is <em>really, really<\/em> easy.\nAssertion functions are <a href=\"https://kotlinlang.org/docs/reference/extensions.html\">extension functions<\/a> on the interface <code>Assertion.Builder&lt;T&gt;<\/code> where <code>T<\/code> is the type of the assertion subject.<\/p>\n<h3 id=\"tip-avoiding-clashing-method-signatures\">Tip: Avoiding clashing method signatures<\/h3>\n<p>Because of Java's generic type erasure, it's possible that the name of your custom assertion function may clash with an existing one for a different subject type.<\/p>\n<p>To avoid this you can add the <code>@JvmName<\/code> annotation to your assertion function to disambiguate the methods.\nSee <a href=\"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#handling-signature-clashes-with-jvmname\">Handling signature clashes with <em>@JvmName<\/em><\/a> in the Kotlin documentation.<\/p>\n<p>For example, if you were defining an <code>isEmpty<\/code> assertion for Gson's <code>JsonArray<\/code> type, you would need to disambiguate it from the <code>isEmpty<\/code> assertion Strikt provides for collections.<\/p>\n<pre><code class=\"language-kotlin\">@JvmName(&quot;isEmpty_JsonArray&quot;)\nfun Assertion.Builder&lt;JsonArray&gt;.isEmpty(): Assertion.Builder&lt;JsonArray&gt; =\n  // ...\n<\/code><\/pre>\n<h2 id=\"atomic-assertions\">Atomic assertions<\/h2>\n<p>&quot;Atomic&quot; assertions produce a single message on failure.\nThey call <code>assert<\/code> passing a lambda with the assertion logic that calls <code>pass()<\/code> or <code>fail()<\/code>.<\/p>\n<p>The standard assertions <code>isNull<\/code>, <code>isEqualTo<\/code>, <code>isA&lt;T&gt;<\/code> and many others are simple assertions implemented just like this.<\/p>\n<p>Let's imagine we're implementing an assertion function for <code>java.time.LocalDate<\/code> that tests if the represented date is a leap day.<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assert(&quot;is St. Tib&#39;s Day&quot;) {\n    when (MonthDay.from(it)) {\n      MonthDay.of(2, 29) -&gt; pass()\n      else -&gt; fail()\n    }\n  }<\/code><\/pre>\n<p>Breaking this down:<\/p>\n<ol>\n<li>We declare the assertion function applies only to <code>Assertion.Builder&lt;LocalDate&gt;<\/code>.<\/li>\n<li>Note that the function also returns <code>Assertion.Builder&lt;LocalDate&gt;<\/code> so we can include this assertion as part of a chain.<\/li>\n<li>We call <code>assert<\/code> passing a description of the assertion and a lambda with the assertion logic.<\/li>\n<li>If <code>it<\/code> (the test subject) is the value we want we call <code>pass()<\/code> otherwise we call <code>fail()<\/code><\/li>\n<\/ol>\n<p>If this assertion fails it will produce a message like:<\/p>\n<pre><code class=\"language-text\">▼ Expect that 2018-05-01:\n  ✗ is St. Tib&#39;s Day<\/code><\/pre>\n<h3 id=\"note\">Note<\/h3>\n<p>The method <code>assert<\/code> accepts a description for the assertion being made and a lambda function <code>Assertion&lt;T&gt;.(T) -&gt; Unit<\/code>.\nThe parameter passed to the lambda is the assertion subject.\nThe <code>Assertion&lt;T&gt;<\/code> receiver provides the lambda the <code>pass()<\/code> and <code>fail()<\/code> methods for reporting the assertion result.<\/p>\n<h2 id=\"describing-the-actual-value\">Describing the &quot;actual&quot; value<\/h2>\n<p>For assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.<\/p>\n<p>In order to do this, Strikt provides an overridden version of <code>fail()<\/code> that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assert(&quot;is St. Tib&#39;s Day&quot;) {\n    when (MonthDay.from(it)) {\n      MonthDay.of(2, 29) -&gt; pass()\n      else -&gt; fail(\n        description = &quot;in fact it is %s&quot;,\n        actual = it\n      )\n    }\n  }<\/code><\/pre>\n<p>Now if the assertion fails there is a little more detail.<\/p>\n<pre><code class=\"language-text\">▼ Expect that 2018-05-01:\n  ✗ is St. Tib&#39;s Day : in fact it is 2018-05-01<\/code><\/pre>\n<p>In this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.\nWhen comparing large string values it also means IDEs such as IntelliJ IDEA will present a detailed diff dialog in the event of a test failure.<\/p>\n<h2 id=\"simple-atomic-assertions-with-boolean-expressions\">Simple atomic assertions with boolean expressions<\/h2>\n<p>For the simplest assertion functions, instead of using <code>assert<\/code> and calling <code>pass<\/code> or <code>fail<\/code>, you can use <code>assertThat<\/code> with a lambda whose parameter is the assertion subject that returns a boolean.<\/p>\n<p>We can re-implement the example above like this:<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assertThat(&quot;is St. Tib&#39;s Day&quot;) {\n    MonthDay.from(it) == MonthDay.of(2, 29)\n  }<\/code><\/pre>\n<p>You should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.<\/p>\n<h2 id=\"composed-assertions\">Composed assertions<\/h2>\n<p>For more complex assertion implementations you can &quot;nest&quot; sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.<\/p>\n<p>Composed assertions are useful for things like:<\/p>\n<ul>\n<li>applying assertions to multiple properties of an object, for example for a field-by-field comparison.<\/li>\n<li>applying assertions to all elements of a collection or entries in a map, reporting on individual elements.<\/li>\n<\/ul>\n<p>Imagine we're creating an assertion function that tests fails if any element of a collection is <code>null<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">fun &lt;T : Iterable&lt;E?&gt;, E&gt; Assertion.Builder&lt;T&gt;.containsNoNullElements(): Assertion.Builder&lt;T&gt; =\n  compose(&quot;does not contain any null elements&quot;) { subject -&gt;\n    subject.forEach { element -&gt;\n      get(&quot;%s&quot;) { element }.isNotNull()\n    }\n  } then {\n    if (allPassed) pass() else fail()\n  }<\/code><\/pre>\n<p>Breaking this down:<\/p>\n<ol>\n<li>We declare the overall assertion function applies to an <code>Iterable<\/code> of a nullable element type <code>E<\/code>.<\/li>\n<li>We use the <code>compose<\/code> method instead of <code>assert<\/code>.<\/li>\n<li>Inside the <code>compose<\/code> block we make assertions about each element of the iterable subject.<\/li>\n<li>Inside the <code>then<\/code> block we pass or fail the overall assertion depending on whether the nested assertions all passed.<\/li>\n<\/ol>\n<p>The receiver of the block passed to <code>result<\/code> has the properties <code>allFailed<\/code>, <code>anyFailed<\/code>, <code>allPassed<\/code> and <code>anyPassed<\/code> along with <code>pass()<\/code> and <code>fail()<\/code> functions used in simple assertions.<\/p>\n<p>If the assertion failed we'll see something like this:<\/p>\n<pre><code class=\"language-text\">▼ Expect that [&quot;catflap&quot;, null, &quot;rubberplant&quot;, &quot;marzipan&quot;]:\n  ✗ does not contain any null elements\n    ▼ &quot;catflap&quot;:\n      ✓ is not null\n    ▼ null:\n      ✗ is not null\n    ▼ &quot;rubberplant&quot;:\n      ✓ is not null\n    ▼ &quot;marzipan&quot;:\n      ✓ is not null<\/code><\/pre>\n<p>As well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.<\/p>\n<p>Several assertion functions in Strikt's standard assertions library use nested assertions.\nFor example, <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.all<\/code> applies assertions to each element of an <code>Iterable<\/code> then passes the overall assertion if (and only if) all those nested assertions passed (<code>allPassed<\/code>).\nOn the other hand <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.any<\/code> applies assertions to the elements of an <code>Iterable<\/code> but will pass the overall assertion if at least one of those nested assertions passed (<code>anyPassed<\/code>).\nThe <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.none<\/code> assertion passes only if <code>allFailed<\/code> is true for its nested assertions!<\/p>\n"
        }]
      },
      "getting-started": {
        "ownKey": "getting-started",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "getting-started",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/getting-started"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "assertion-styles",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/assertion-styles"
          },
          "description": "",
          "title": "Getting Started",
          "content": "<h1 id=\"getting-started\">Getting Started<\/h1>\n<p>Strikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.<\/p>\n<h2 id=\"installation\">Installation<\/h2>\n<p>Strikt is available from JCenter.\nAdd the following to your <code>build.gradle<\/code> or <code>build.gradle.kts<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">repositories {\n  jcenter()\n}\n\ndependencies {\n  testImplementation(&quot;io.strikt:strikt-core:0.19.6&quot;)\n}\n<\/code><\/pre>\n<h2 id=\"importing-the-strikt-api\">Importing the Strikt API<\/h2>\n<p>Add the following imports to your test:<\/p>\n<pre><code class=\"language-kotlin\">import strikt.api.*\nimport strikt.assertions.*\n<\/code><\/pre>\n<p>The <code>strikt.api<\/code> package contains top level functions such as <code>expect<\/code>, <code>expectThat<\/code>, and <code>expectThrows<\/code> that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe <code>strikt.assertions<\/code> package contains the standard library of assertion functions.<\/p>\n"
        }]
      },
      "additional-modules": {
        "ownKey": "additional-modules",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "additional-modules",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/additional-modules"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "custom-assertions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/custom-assertions"
          },
          "description": "",
          "title": "Additional Modules",
          "content": "<h1 id=\"additional-modules\">Additional Modules<\/h1>\n<p>In addition to the core functionality provided by the <code>strikt-core<\/code> module, Strikt has the following optional modules:<\/p>\n<h2 id=\"jackson\">Jackson<\/h2>\n<p>Extensions for assertions and traversals on types <a href=\"https://github.com/FasterXML/jackson\">Jackson<\/a>'s <code>JsonNode<\/code> and sub-types.\nSee the <a href=\"https://strikt.io/strikt/jackson\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-jackson:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"java-time\">Java Time<\/h2>\n<p>Extensions for assertions and traversals on types from the <code>java.time<\/code> package.\nSee the <a href=\"https://strikt.io/strikt/time\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-java-time:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"protobuf\">Protobuf<\/h2>\n<p>Extensions for testing code that uses Protobuf / gRPC.\nSee the <a href=\"https://strikt.io/strikt/protobuf\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-protobuf:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"using-the-bill-of-materials-bom\">Using the Bill of Materials (BOM)<\/h2>\n<p>If you're using multiple Strikt modules (and Gradle &gt;= 5.0) you can import Strikt's BOM and then omit versions for individual modules.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">dependencies {\n  testImplementation(platform(&quot;io.strikt:strikt-bom:0.19.6&quot;))\n  testImplementation(&quot;io.strikt:strikt-jackson&quot;)\n  testImplementation(&quot;io.strikt:strikt-java-time&quot;)\n}\n<\/code><\/pre>\n"
        }]
      },
      "expecting-exceptions": {
        "ownKey": "expecting-exceptions",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "expecting-exceptions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/expecting-exceptions"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "flow-typing",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/flow-typing"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "collection-elements",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/collection-elements"
          },
          "description": "",
          "title": "Expecting Exceptions",
          "content": "<h1 id=\"asserting-exceptions-are-thrown\">Asserting exceptions are thrown<\/h1>\n<p>To assert that some code throws an exception you can use the <code>catching<\/code> function that accepts a lambda <code>() -&gt; Unit<\/code> that performs the operation that should throw an exception and the <code>throws&lt;E&gt;<\/code> assertion function.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(catching { identifyHotdog(&quot;hamburger&quot;) })\n  .throws&lt;NotHotdogException&gt;()<\/code><\/pre>\n<p>The <code>catching<\/code> function returns <code>Throwable?<\/code> with the value being whatever exception is thrown by the lambda, or <code>null<\/code> if nothing is thrown.\nCombining it with the <code>throws&lt;E&gt;<\/code> assertion allows testing for specific exception types.\nThe <code>throws&lt;E&gt;<\/code> assertion will fail if the exception is <code>null<\/code> or the wrong type.<\/p>\n<p>The <code>throws&lt;E&gt;<\/code> function returns an <code>Assertion.Builder&lt;E&gt;<\/code> so you can chain assertions about the exception itself after it.<\/p>\n<p>If you just need to test that <em>any<\/em> exception was or was not thrown you can combine <code>catching<\/code> with <code>isNull<\/code> or <code>isNotNull<\/code>.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(catching { identifyHotdog(&quot;hotdog&quot;) })\n  .isNull()<\/code><\/pre>\n<h2 id=\"shorthand-form\">Shorthand form<\/h2>\n<p>You can also use the <code>expectThrows&lt;E&gt;(A)<\/code> function which is simply a shorthand for the <code>expectThat<\/code> / <code>catching<\/code> / <code>throws<\/code> combination.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThrows&lt;NotHotdogException&gt; {\n  identifyHotdog(&quot;hamburger&quot;)\n}<\/code><\/pre>\n"
        }]
      },
      "grouping-with-and": {
        "ownKey": "grouping-with-and",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "grouping-with-and",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/grouping-with-and"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "custom-assertions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/custom-assertions"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "traversing-subjects",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/traversing-subjects"
          },
          "description": "",
          "title": "Grouping Assertions With and",
          "content": "<h1 id=\"grouping-assertions-with-and\">Grouping Assertions with <em>and<\/em><\/h1>\n<p>Strikt provides the <code>and<\/code> method that is used to add a block of assertions to a chain.\nThis is useful in a couple of scenarios.<\/p>\n<h2 id=\"grouping-assertions-after-a-null-or-type-check\">Grouping assertions after a null or type check<\/h2>\n<p>It's frequently useful to be able to perform a block of assertions after narrowing the subject type.\nFor example, if the declared type of an assertion subject is nullable it can be awkward to apply a block of assertions directly with <code>expectThat<\/code> as every individual assertion in the block needs to deal with the nullable type.<\/p>\n<p>The same is true when the subject type is overly broad and you need to narrow the type with <code>isA&lt;T&gt;<\/code> in order to use assertion functions that are specific to the runtime type.<\/p>\n<p>The <code>and<\/code> method is helpful in these scenarios.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(subject)\n  .isNotNull()\n  .and {\n    // perform other assertions on a known non-null subject\n  }<\/code><\/pre>\n<p>The type after <code>expectThat<\/code> is <code>Assertion.Builder&lt;T?&gt;<\/code> (assuming <code>subject<\/code> has a nullable declared type) but the receiever of <code>and<\/code> is <code>Assertion.Builder&lt;T&gt;<\/code> as <code>isNotNull<\/code> has narrowed the subject type.<\/p>\n<h2 id=\"making-assertions-on-sub-trees-of-a-subject\">Making assertions on sub-trees of a subject<\/h2>\n<p>Another use for <code>and<\/code> is to create a branch of assertions that apply to a sub-tree of the subject.\nFor example, if testing a complex value type with nested properties:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(person)\n  .and {\n    get { name }.isEqualTo(&quot;David&quot;)\n  }\n  .and {\n    get { birthDate.year }.isEqualTo(1947)\n  }<\/code><\/pre>\n<p>Of course, it may be better to structure the same assertion with separate assertions.\nThis is a lot more readable:<\/p>\n<pre><code class=\"language-kotlin\">expect {\n  that(person.name).isEqualTo(&quot;David&quot;)\n  that(person.birthDate.year).isEqualTo(1947)\n}<\/code><\/pre>\n<p>Testing properties of a collection can be done in a similar way:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(albums)\n  .hasSize(26)\n  .and { first().get { name }.isEqualTo(&quot;David Bowie&quot;) }\n  .and { last().get { name }.isEqualTo(&quot;Blackstar&quot;) }<\/code><\/pre>\n"
        }]
      },
      "collection-elements": {
        "ownKey": "collection-elements",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "collection-elements",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/collection-elements"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "expecting-exceptions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/expecting-exceptions"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "assertion-styles",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/assertion-styles"
          },
          "description": "",
          "title": "Collection Element Assertions",
          "content": "<h1 id=\"assertions-on-elements-of-a-collection\">Assertions on elements of a collection<\/h1>\n<p>Some assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that <em>all<\/em> elements conform to a repeated assertion.<\/p>\n<pre><code class=\"language-kotlin\">val subject = setOf(&quot;catflap&quot;, &quot;rubberplant&quot;, &quot;marzipan&quot;)\nexpectThat(subject).all {\n  isLowerCase()\n  startsWith(&#39;c&#39;)\n}<\/code><\/pre>\n<p>This produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that [&quot;catflap&quot;, &quot;rubberplant&quot;, &quot;marzipan&quot;]:\n  ✗ all elements match:\n    ▼ &quot;catflap&quot;:\n      ✓ is lower case\n      ✓ starts with &#39;c&#39;\n    ▼ &quot;rubberplant&quot;:\n      ✓ is lower case\n      ✗ starts with &#39;c&#39; : found &#39;r&#39;\n    ▼ &quot;marzipan&quot;:\n      ✓ is lower case\n      ✗ starts with &#39;c&#39; : found &#39;m&#39;<\/code><\/pre>\n<p>The results are broken down by individual elements in the collection so it's easy to see which failed.<\/p>\n<p>Similarly, <code>any<\/code> asserts that at least one element passes the nested assertions and <code>none<\/code> succeeds if all elements of the collection <em>fail<\/em> the nested assertions.<\/p>\n"
        }]
      },
      "flow-typing": {
        "ownKey": "flow-typing",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "flow-typing",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/flow-typing"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "traversing-subjects",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/traversing-subjects"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "expecting-exceptions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/expecting-exceptions"
          },
          "description": "",
          "title": "Strongly Typed Assertions",
          "content": "<h1 id=\"strongly-typed-assertions\">Strongly Typed Assertions<\/h1>\n<p>Strikt's API is designed to work with Kotlin's strong type system.<\/p>\n<p>Strikt's assertion API uses the interface <code>Assertion.Builder&lt;T&gt;<\/code>, with the generic type <code>T<\/code> representing the (declared) type of the assertion subject.\nAssertion functions such as <code>isEqualTo<\/code> are implemented as extension functions on <code>Assertion.Builder<\/code> with an appropriate generic type.<\/p>\n<p>For example <code>isEqualTo<\/code> is an extension function on <code>Assertion.Builder&lt;Any?&gt;<\/code> as it's useful for many types of subject whereas <code>isEqualToIgnoringCase<\/code> is an extension function on <code>Assertion.Builder&lt;CharSequence&gt;<\/code> since it only makes sense to use it on string-like things.<\/p>\n<p>Some assertion functions will return an <code>Assertion.Builder<\/code> with a <em>different<\/em>, more specific, generic type to the one they were called on.<\/p>\n<h2 id=\"nullable-subjects\">Nullable subjects<\/h2>\n<p>For example, if the subject of an assertion is a nullable type (in other words it's an <code>Assertion.Builder&lt;T?&gt;<\/code>) the assertion methods <code>isNull()<\/code> and <code>isNotNull()<\/code> are available.\nThe return type of <code>isNotNull()<\/code> is <code>Assertion.Builder&lt;T&gt;<\/code> because we now <em>know<\/em> the subject is not null.\nYou will find IDE code-completion will no longer offer the <code>isNull()<\/code> and <code>isNotNull()<\/code> assertion methods.<\/p>\n<h2 id=\"narrowing-assertions\">Narrowing assertions<\/h2>\n<p>Another example is making assertions about a subject's specific runtime type, or &quot;narrowing&quot;.<\/p>\n<p>For example:<\/p>\n<pre><code class=\"language-kotlin\">val subject: Map&lt;String, Any&gt; = mapOf(&quot;count&quot; to 1, &quot;name&quot; to &quot;Rob&quot;)\nexpectThat(subject[&quot;count&quot;])\n  .isA&lt;Int&gt;()\n  .isGreaterThan(0)\n\nexpectThat(subject[&quot;name&quot;])\n  .isA&lt;String&gt;()\n  .hasLength(3)<\/code><\/pre>\n<p>The return type of the subject map's <code>get()<\/code> method is <code>Any<\/code> but using the narrowing assertion <code>isA&lt;T&gt;()<\/code> we can both assert the type of the value and, because the compiler now knows it is dealing with an <code>Assertion.Builder&lt;String&gt;<\/code> or an <code>Assertion.Builder&lt;Number&gt;<\/code>, we can use more specialized assertion methods that are only available for those subject types.<\/p>\n<p>Without the <code>isA&lt;T&gt;()<\/code> assertion the code would not compile:<\/p>\n<pre><code class=\"language-kotlin\">val subject: Map&lt;String, Any&gt; = mapOf(&quot;count&quot; to 1, &quot;name&quot; to &quot;Rob&quot;)\nexpectThat(subject.get(&quot;count&quot;))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion.Builder&lt;Any&gt;\n  \nexpectThat(subject.get(&quot;name&quot;))\n  .hasLength(3) \n  // hasLength does not exist on Assertion.Builder&lt;Any&gt;\n<\/code><\/pre>\n<p>This mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.<\/p>\n"
        }]
      },
      "assertion-styles": {
        "ownKey": "assertion-styles",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "assertion-styles",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/assertion-styles"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "collection-elements",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/collection-elements"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "getting-started",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/getting-started"
          },
          "description": "",
          "title": "Assertion Styles",
          "content": "<h1 id=\"assertion-styles\">Assertion styles<\/h1>\n<p>Two different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.<\/p>\n<h2 id=\"chained-assertions\">Chained assertions<\/h2>\n<p>Chained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.<\/p>\n<p>Each assertion in the chain returns an <code>Assertion.Builder<\/code> object that supports further assertions.<\/p>\n<pre><code class=\"language-kotlin\">val subject = &quot;fnord&quot;\nexpectThat(subject)\n  .isA&lt;String&gt;()\n  .hasLength(1)\n  .isUpperCase()<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that &quot;fnord&quot;:\n  ✓ is an instance of java.lang.String\n  ✗ has length 1 : found 5<\/code><\/pre>\n<p>Notice that the <code>isUpperCase()<\/code> assertion is not applied as the earlier <code>hasLength(1)<\/code> assertion failed.<\/p>\n<h2 id=\"block-assertions\">Block assertions<\/h2>\n<p>Block assertions are declared in a lambda whose receiver is an <code>Assertion.Builder&lt;T&gt;<\/code> object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.<\/p>\n<p>Block assertions do <em>not<\/em> fail fast.\nThat is, all assertions in the block are evaluated and the result of the &quot;compound&quot; assertion will include results for all the assertions made in the block.<\/p>\n<pre><code class=\"language-kotlin\">val subject = &quot;fnord&quot;\nexpectThat(subject) {\n  isA&lt;String&gt;()\n  hasLength(1)\n  isUpperCase()\n}<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that &quot;fnord&quot;:\n  ✓ is an instance of java.lang.String\n  ✗ has length 1 : found 5\n  ✗ is upper case<\/code><\/pre>\n<p>All assertions are applied and since two fail there are two errors logged.<\/p>\n<h3 id=\"chained-assertions-inside-block-assertions\">Chained assertions inside block assertions<\/h3>\n<p>Chained assertions inside a block <em>will<\/em> still fail fast but will not prevent other assertions in the block from being evaluated.<\/p>\n<pre><code class=\"language-kotlin\">val subject = 1L\nexpectThat(subject) {\n  isLessThan(1L).isA&lt;Int&gt;()\n  isGreaterThan(1L)\n}<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that 1:\n  ✗ is less than 1\n  ✗ is greater than 1<\/code><\/pre>\n<p>Note the <code>isA&lt;Int&gt;<\/code> assertion (that would have failed) was not evaluated since it was chained after <code>lessThan(1)<\/code> which failed.\nThe <code>greaterThan(1)<\/code> assertion <em>was<\/em> evaluated since it was not part of the same chain.<\/p>\n<h2 id=\"assertions-with-multiple-subjects\">Assertions with multiple subjects<\/h2>\n<p>As well as <code>expectThat<\/code> Strikt provides a top-level <code>expect<\/code> method that just takes a lambda parameter.\nInside the <code>expect<\/code> block you use <code>that<\/code> to define a subject and start a chain or nested block of assertions.<\/p>\n<p>All assertions inside the <code>expect<\/code> lambda are evaluated.<\/p>\n<p>The previous examples can be combined into a single <code>expect<\/code> block.<\/p>\n<pre><code class=\"language-kotlin\">expect {\n  that(&quot;fnord&quot;)\n    .isA&lt;String&gt;()\n    .hasLength(1)\n    .isUpperCase()\n  that(1L) {\n    isLessThan(1L).isA&lt;Int&gt;()\n    isGreaterThan(1L)\n  }\n}<\/code><\/pre>\n"
        }]
      },
      "traversing-subjects": {
        "ownKey": "traversing-subjects",
        "ownPages": [{
          "reference": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "traversing-subjects",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/traversing-subjects"
          },
          "next": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "grouping-with-and",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/grouping-with-and"
          },
          "previous": {
            "path": "wiki",
            "baseUrl": "https://strikt.io",
            "fileName": "flow-typing",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/wiki/flow-typing"
          },
          "description": "",
          "title": "Traversing Assertion Subjects",
          "content": "<h1 id=\"traversing-assertion-subjects\">Traversing Assertion Subjects<\/h1>\n<p>Although you can obviously write assertions for the properties of an object with code like this:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(map.size).isEqualTo(1)\nexpectThat(list.first()).isEqualTo(&quot;fnord&quot;)\nexpectThat(person.name).isEqualTo(&quot;Ziggy&quot;)<\/code><\/pre>\n<p>Sometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nParticularly when using soft assertion blocks.<\/p>\n<p>Strikt allows for this using the <code>Assertion.Builder&lt;T&gt;.get<\/code> method.<\/p>\n<h2 id=\"using-get-with-lambdas\">Using <em>get<\/em> with lambdas<\/h2>\n<p>The method takes a lambda whose receiver is the current subject and returns an <code>Assertion.Builder&lt;R&gt;<\/code> where <code>R<\/code> (the new subject) is the type of whatever the lambda returns.<\/p>\n<p>This is useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  get { name }.isEqualTo(&quot;Ziggy&quot;)\n  get { birthDate.year }.isEqualTo(1971)\n}<\/code><\/pre>\n<p>Strikt will read the test source to find out the name of the variables.\nThis example produces output that looks like this:<\/p>\n<pre><code class=\"language-text\">▼ Expect that Person(name=David, birthDate=1947-01-08):\n  ▼ name:\n    ✗ is equal to &quot;Ziggy&quot; : found &quot;David&quot;\n  ▼ birthDate.year:\n    ✗ is equal to 1971 : found 1947<\/code><\/pre>\n<h2 id=\"using-get-with-property-or-method-references\">Using <em>get<\/em> with property or method references<\/h2>\n<p>It's also possible to use a property or method reference in place of a lambda.<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  get(Person::name).isEqualTo(&quot;David&quot;)\n  get(Person::birthDate).get(LocalDate::getYear).isEqualTo(1947)\n}<\/code><\/pre>\n<h2 id=\"mapping-elements-of-collections\">Mapping elements of collections<\/h2>\n<p>If the assertion subject is an <code>Iterable<\/code> Strikt provides a <code>map<\/code> function much like the one in the Kotlin standard library.\nIt is effectively like using <code>get<\/code> on each element of the <code>Iterable<\/code> subject.<\/p>\n<pre><code class=\"language-kotlin\">val subject: List&lt;Person&gt; = getPersonList()\nexpectThat(subject)\n  .map(Person::name)\n  .containsExactly(&quot;David&quot;, &quot;Ziggy&quot;, &quot;Aladdin&quot;, &quot;Jareth&quot;)<\/code><\/pre>\n<p>In this case the <code>map<\/code> function is transforming the <code>Assertion.Buidler&lt;List&lt;Person&gt;&gt;<\/code> into an <code>Assertion.Builder&lt;List&lt;String&gt;&gt;<\/code> by applying the <code>name<\/code> property to each element.<\/p>\n<h2 id=\"re-usable-mapping-extensions\">Re-usable mapping extensions<\/h2>\n<p>If you find yourself frequently using <code>get<\/code> for the same properties or methods, consider defining extension property or method to make things even easier.<\/p>\n<p>For example:<\/p>\n<pre><code class=\"language-kotlin\">val Assertion.Builder&lt;Person&gt;.name: Assertion.Builder&lt;String&gt;\n  get() = get(Person::name)\n\nval Assertion.Builder&lt;Person&gt;.yearOfBirth: Assertion.Builder&lt;Int&gt;\n  get() = get(&quot;year of birth&quot;) { birthDate.year }<\/code><\/pre>\n<p>You can then write the earlier example as:<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  name.isEqualTo(&quot;David&quot;)\n  yearOfBirth.isEqualTo(1947)\n}<\/code><\/pre>\n<h2 id=\"built-in-traversals\">Built-in traversals<\/h2>\n<p>Strikt has a number of built in traversal properties and functions such as <code>Assertion.Builder&lt;List&lt;E&gt;&gt;.first()<\/code> which returns an <code>Assertion.Builder&lt;E&gt;<\/code> whose subject is the first element of the list.\nSee the <a href=\"https://strikt.io/strikt/assertions\">API docs<\/a> for details.<\/p>\n"
        }]
      }
    },
    "ownPages": [{
      "reference": {
        "path": "",
        "baseUrl": "https://strikt.io",
        "fileName": "wiki",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://strikt.io/wiki"
      },
      "description": "",
      "title": "Wiki",
      "content": "<html>\n <head><\/head>\n <body>\n  <ul> \n   <li><a href=\"https://strikt.io/wiki/getting-started\">Getting Started<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/assertion-styles\">Assertion Styles<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/collection-elements\">Collection Element Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/expecting-exceptions\">Expecting Exceptions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/flow-typing\">Strongly Typed Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/traversing-subjects\">Traversing Assertion Subjects<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/grouping-with-and\">Grouping Assertions With and<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/custom-assertions\">Custom Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/additional-modules\">Additional Modules<\/a><\/li> \n  <\/ul> \n <\/body>\n<\/html>\n"
    }]
  }}
}