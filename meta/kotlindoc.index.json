{
  "ownKey": "kotlindoc",
  "childrenPages": {"strikt": {
    "ownKey": "strikt",
    "childrenPages": {
      "spring": {
        "ownKey": "spring",
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "spring",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/spring"
          },
          "description": "",
          "title": "strikt.spring",
          "content": "<p>isCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
        }]
      },
      "protobuf": {
        "ownKey": "protobuf",
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "protobuf",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/protobuf"
          },
          "description": "",
          "title": "strikt.protobuf",
          "content": "<p>isEmpty\nAsserts that a <code>com.google.protobuf.Any<\/code> is empty and does not contain an\nobject of any kind.\nunpacksTo\nAsserts that the subject is a message of type T.\nunpack\nMaps an assertion on <code>com.google.protobuf.Any<\/code> to an assertion on an unpacked\nmessage of type T.<\/p>\n"
        }]
      },
      "jackson": {
        "ownKey": "jackson",
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "jackson",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/jackson"
          },
          "description": "",
          "title": "strikt.jackson",
          "content": "<p>has\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nhasSize\nAsserts that a JSON array's size is equal to expected.\nsize\nMaps an assertion on a JSON array to an assertion on its size.<\/p>\n"
        }]
      },
      "api": {
        "ownKey": "api",
        "childrenPages": {
          "AtomicAssertion": {
            "ownKey": "AtomicAssertion",
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "AtomicAssertion",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/AtomicAssertion"
              },
              "description": "",
              "title": "AtomicAssertion",
              "content": "<p>An assertion of a single condition on a subject.<\/p>\n<p>fail\nMark this result as failed due to a comparison between two values.<\/p>\n"
            }]
          },
          "Assertion": {
            "ownKey": "Assertion",
            "childrenPages": {"Builder": {
              "ownKey": "Builder",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api/Assertion",
                  "baseUrl": "https://strikt.io",
                  "fileName": "Builder",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/Assertion/Builder"
                },
                "description": "",
                "title": "Builder",
                "content": "<p>Used to construct assertions.<\/p>\n<p>assert\nEvaluates a condition that may pass or fail.<p>While this method <i>can<\/i> be used directly in a test but is typically used\ninside an extension method on <code>Assertion.Builder<T><\/code> such as those\nprovided in the strikt.assertions package.<\/p>\nassert\nEvaluates a condition that may pass or fail.<p>While this method <i>can<\/i> be used directly in a test but is typically used\ninside an extension method on <code>Assertion.Builder<T><\/code> such as those\nprovided in the strikt.assertions package.<\/p>\ncompose\nAllows an assertion to be composed of multiple sub-assertions such as on\nfields of an object or elements of a collection.<p>The results of assertions made inside the assertions block are included\nunder the overall assertion result.<\/p>\ncompose\nAllows an assertion to be composed of multiple sub-assertions such as on\nfields of an object or elements of a collection.<p>The results of assertions made inside the assertions block are included\nunder the overall assertion result.<\/p>\npassesIf\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\npassesIf\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nassertThat\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nassertThat\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nget\nMaps the assertion subject to the result of function.\nThis is useful for chaining to property values or method call results on\nthe subject.<p>If function is a callable reference, (for example a getter or property\nreference) the subject description will be automatically determined for\nthe returned assertion builder.<\/p><p>If function is a lambda, Strikt will make a best-effort attempt to\ndetermine an appropriate function / property name.<\/p>\nget\nMaps the assertion subject to the result of function.\nThis is useful for chaining to property values or method call results on\nthe subject.\nchain\nDeprecated form of get<code>((T) -&gt; R)<\/code>.\nchain\nDeprecated form of get<code>(String, (T) -&gt; R)<\/code>.\nnot\nReverses any assertions chained after this method.\nnot\nEvaluates a block of assertions on the current subject by executing them in reverse.\nand\nEvaluates a block of assertions on the current subject.<p>The main use for this method is after strikt.assertions.isNotNull or\nstrikt.assertions.isA in order that a group of assertions can more\nconveniently be performed on the narrowed subject type.<\/p><p>This method may be used as an infix function which tends to enhance\nreadability when it directly follows a lambda.<\/p>\nisNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nBooleanArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nByteArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nShortArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nIntArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nLongArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nFloatArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nDoubleArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nCharArray.contentEquals.\ntoList\nMaps an array to a list to make it possible to use the iterable matchers\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisEmpty\nAsserts that the subject is the empty string.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotEmpty\nAsserts that the subject is not the empty string (contains at least one\ncharacter).\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\ntrim\nTrims the subject string.\nhasSize\nAsserts that the subject has a Collection.size of exactly expected.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nfilterIsInstance\nMaps this assertion to an assertion over a list of all elements of the subject that are instances of <code>R<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nisPresent\nAsserts that an <code>Optional<\/code> contains a value (is not empty) and returns an\nassertion builder whose subject is the value.\nisAbsent\nAsserts that an <code>Optional<\/code> does not contain a value.\ntoNullable\nMaps an assertion on a Java <code>Optional<\/code> to a Kotlin nullable type.\nisEqualToIgnoringCase\nAsserts that the subject is equal to the expected value regardless of case.\nthrows\nAsserts that an exception is an instance of the expected type.\nThe assertion fails if the subject is <code>null<\/code> or not an instance of E.<p>This assertion is designed for use with the strikt.api.catching function.<\/p>\nhas\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nhasSize\nAsserts that a JSON array's size is equal to expected.\nsize\nMaps an assertion on a JSON array to an assertion on its size.\nisBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\nisEmpty\nAsserts that a <code>com.google.protobuf.Any<\/code> is empty and does not contain an\nobject of any kind.\nunpacksTo\nAsserts that the subject is a message of type T.\nunpack\nMaps an assertion on <code>com.google.protobuf.Any<\/code> to an assertion on an unpacked\nmessage of type T.\nisCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
              }]
            }},
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "Assertion",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/Assertion"
              },
              "description": "",
              "title": "Assertion",
              "content": "<p>Allows assertion implementations to determine a result.<\/p>\n<p>pass\nMark this result as passed.\nfail\nMark this result as failed.<\/p>\n"
            }]
          },
          "DescribeableBuilder": {
            "ownKey": "DescribeableBuilder",
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "DescribeableBuilder",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/DescribeableBuilder"
              },
              "description": "",
              "title": "DescribeableBuilder",
              "content": "<p>Extension of Assertion.Builder that enables the description of the\nassertion subject.<p>Since it doesn't make sense to do this anywhere except directly after the\ninitial expectThat or Assertion.Builder.get call those methods return an\ninstance of this interface, while assertions themselves just return\nAssertion.Builder.<\/p><\/p>\n<p>describedAs\nAdds a description to the assertion.\nisNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nhas\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nisBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\nisCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
            }]
          },
          "ExpectationBuilder": {
            "ownKey": "ExpectationBuilder",
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "ExpectationBuilder",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/ExpectationBuilder"
              },
              "description": "",
              "title": "ExpectationBuilder",
              "content": "<p>Receiver for expect providing functions that define assertion subjects and\ncreate assertion chains or blocks.<\/p>\n<p>that\nStart a chain of assertions over subject.\nthat\nEvaluate a block of assertions over subject.<\/p>\n"
            }]
          },
          "CompoundAssertions": {
            "ownKey": "CompoundAssertions",
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "CompoundAssertions",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/CompoundAssertions"
              },
              "description": "",
              "title": "CompoundAssertions",
              "content": "<p>Returned by Assertion.Builder.compose allowing a bridge between evaluation\nof composed assertions and the determination of the overall result in the\n<code>block<\/code> parameter passed to then.<\/p>\n<p>then\nDetermine the overall status of a compound assertion based on the results\nof its child assertions.<\/p>\n"
            }]
          },
          "CompoundAssertion": {
            "ownKey": "CompoundAssertion",
            "ownPages": [{
              "reference": {
                "path": "strikt/api",
                "baseUrl": "https://strikt.io",
                "fileName": "CompoundAssertion",
                "extension": "html",
                "usePrettyUrl": true,
                "link": "https://strikt.io/strikt/api/CompoundAssertion"
              },
              "description": "",
              "title": "CompoundAssertion",
              "content": "<p>An assertion composed of multiple conditions whose overall result is\ndetermined by some aggregation of those conditions' results.\nanyFailed\n<code>true<\/code> if at least one composed assertion failed,\notherwise <code>false<\/code>.\nallFailed\n<code>true<\/code> if all composed assertions failed, otherwise\n<code>false<\/code>.\nanyPassed\n<code>true<\/code> if at least one composed assertion passed,\notherwise <code>false<\/code>.\nallPassed\n<code>true<\/code> if all composed assertions passed, otherwise\n<code>false<\/code>.\npassedCount\nthe number of composed assertions whose status is\nstrikt.api.Status.Passed.\nfailedCount\nthe number of composed assertions whose status is\nstrikt.api.Status.Failed.<\/p>\n"
            }]
          }
        },
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "api",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/api"
          },
          "description": "",
          "title": "strikt.api",
          "content": "<p>catching\nExecutes action, catching and returning any exception that is thrown. If\nno exception is thrown the method returns <code>null<\/code>.\nexpect\nStarts a block of assertions that will all be evaluated regardless of whether\nearlier ones fail.\nThis is the entry-point for the assertion API.\nexpectThat\nStart a chain of assertions over subject.\nThis is the entry-point for the assertion API.\nexpectThat\nEvaluate a block of assertions over subject.\nThis is the entry-point for the assertion API.\nexpectThrows\nAsserts that actionthrows an exception of type E when executed.<\/p>\n"
        }]
      },
      "time": {
        "ownKey": "time",
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "time",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/time"
          },
          "description": "",
          "title": "strikt.time",
          "content": "<p>isBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.<\/p>\n"
        }]
      },
      "assertions": {
        "ownKey": "assertions",
        "ownPages": [{
          "reference": {
            "path": "strikt",
            "baseUrl": "https://strikt.io",
            "fileName": "assertions",
            "extension": "html",
            "usePrettyUrl": true,
            "link": "https://strikt.io/strikt/assertions"
          },
          "description": "",
          "title": "strikt.assertions",
          "content": "<p>isNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nBooleanArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nByteArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nShortArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nIntArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nLongArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nFloatArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nDoubleArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nCharArray.contentEquals.\ntoList\nMaps an array to a list to make it possible to use the iterable matchers\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisEmpty\nAsserts that the subject is the empty string.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotEmpty\nAsserts that the subject is not the empty string (contains at least one\ncharacter).\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\ntrim\nTrims the subject string.\nhasSize\nAsserts that the subject has a Collection.size of exactly expected.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nfilterIsInstance\nMaps this assertion to an assertion over a list of all elements of the subject that are instances of <code>R<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nisPresent\nAsserts that an <code>Optional<\/code> contains a value (is not empty) and returns an\nassertion builder whose subject is the value.\nisAbsent\nAsserts that an <code>Optional<\/code> does not contain a value.\ntoNullable\nMaps an assertion on a Java <code>Optional<\/code> to a Kotlin nullable type.\nisEqualToIgnoringCase\nAsserts that the subject is equal to the expected value regardless of case.\nthrows\nAsserts that an exception is an instance of the expected type.\nThe assertion fails if the subject is <code>null<\/code> or not an instance of E.<p>This assertion is designed for use with the strikt.api.catching function.<\/p><\/p>\n"
        }]
      }
    }
  }}
}