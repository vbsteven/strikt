{
  "ownKey": "internal",
  "childrenPages": {
    "strikt": {
      "ownKey": "strikt",
      "childrenPages": {
        "spring": {
          "ownKey": "spring",
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "spring",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/spring"
            },
            "description": "",
            "title": "strikt.spring",
            "content": "<p>isCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
          }]
        },
        "protobuf": {
          "ownKey": "protobuf",
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "protobuf",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/protobuf"
            },
            "description": "",
            "title": "strikt.protobuf",
            "content": "<p>isEmpty\nAsserts that a <code>com.google.protobuf.Any<\/code> is empty and does not contain an\nobject of any kind.\nunpacksTo\nAsserts that the subject is a message of type T.\nunpack\nMaps an assertion on <code>com.google.protobuf.Any<\/code> to an assertion on an unpacked\nmessage of type T.<\/p>\n"
          }]
        },
        "jackson": {
          "ownKey": "jackson",
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "jackson",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/jackson"
            },
            "description": "",
            "title": "strikt.jackson",
            "content": "<p>has\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nhasSize\nAsserts that a JSON array's size is equal to expected.\nsize\nMaps an assertion on a JSON array to an assertion on its size.<\/p>\n"
          }]
        },
        "api": {
          "ownKey": "api",
          "childrenPages": {
            "AtomicAssertion": {
              "ownKey": "AtomicAssertion",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "AtomicAssertion",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/AtomicAssertion"
                },
                "description": "",
                "title": "AtomicAssertion",
                "content": "<p>An assertion of a single condition on a subject.<\/p>\n<p>fail\nMark this result as failed due to a comparison between two values.<\/p>\n"
              }]
            },
            "Assertion": {
              "ownKey": "Assertion",
              "childrenPages": {"Builder": {
                "ownKey": "Builder",
                "ownPages": [{
                  "reference": {
                    "path": "strikt/api/Assertion",
                    "baseUrl": "https://strikt.io",
                    "fileName": "Builder",
                    "extension": "html",
                    "usePrettyUrl": true,
                    "link": "https://strikt.io/strikt/api/Assertion/Builder"
                  },
                  "description": "",
                  "title": "Builder",
                  "content": "<p>Used to construct assertions.<\/p>\n<p>assert\nEvaluates a condition that may pass or fail.<p>While this method <i>can<\/i> be used directly in a test but is typically used\ninside an extension method on <code>Assertion.Builder<T><\/code> such as those\nprovided in the strikt.assertions package.<\/p>\nassert\nEvaluates a condition that may pass or fail.<p>While this method <i>can<\/i> be used directly in a test but is typically used\ninside an extension method on <code>Assertion.Builder<T><\/code> such as those\nprovided in the strikt.assertions package.<\/p>\ncompose\nAllows an assertion to be composed of multiple sub-assertions such as on\nfields of an object or elements of a collection.<p>The results of assertions made inside the assertions block are included\nunder the overall assertion result.<\/p>\ncompose\nAllows an assertion to be composed of multiple sub-assertions such as on\nfields of an object or elements of a collection.<p>The results of assertions made inside the assertions block are included\nunder the overall assertion result.<\/p>\npassesIf\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\npassesIf\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nassertThat\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nassertThat\nEvaluates a boolean condition.\nThis is useful for implementing the simplest types of assertion function.\nget\nMaps the assertion subject to the result of function.\nThis is useful for chaining to property values or method call results on\nthe subject.<p>If function is a callable reference, (for example a getter or property\nreference) the subject description will be automatically determined for\nthe returned assertion builder.<\/p><p>If function is a lambda, Strikt will make a best-effort attempt to\ndetermine an appropriate function / property name.<\/p>\nget\nMaps the assertion subject to the result of function.\nThis is useful for chaining to property values or method call results on\nthe subject.\nchain\nDeprecated form of get<code>((T) -&gt; R)<\/code>.\nchain\nDeprecated form of get<code>(String, (T) -&gt; R)<\/code>.\nnot\nReverses any assertions chained after this method.\nnot\nEvaluates a block of assertions on the current subject by executing them in reverse.\nand\nEvaluates a block of assertions on the current subject.<p>The main use for this method is after strikt.assertions.isNotNull or\nstrikt.assertions.isA in order that a group of assertions can more\nconveniently be performed on the narrowed subject type.<\/p><p>This method may be used as an infix function which tends to enhance\nreadability when it directly follows a lambda.<\/p>\nisNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nBooleanArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nByteArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nShortArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nIntArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nLongArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nFloatArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nDoubleArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nCharArray.contentEquals.\ntoList\nMaps an array to a list to make it possible to use the iterable matchers\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisEmpty\nAsserts that the subject is the empty string.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotEmpty\nAsserts that the subject is not the empty string (contains at least one\ncharacter).\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\ntrim\nTrims the subject string.\nhasSize\nAsserts that the subject has a Collection.size of exactly expected.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nfilterIsInstance\nMaps this assertion to an assertion over a list of all elements of the subject that are instances of <code>R<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nisPresent\nAsserts that an <code>Optional<\/code> contains a value (is not empty) and returns an\nassertion builder whose subject is the value.\nisAbsent\nAsserts that an <code>Optional<\/code> does not contain a value.\ntoNullable\nMaps an assertion on a Java <code>Optional<\/code> to a Kotlin nullable type.\nisEqualToIgnoringCase\nAsserts that the subject is equal to the expected value regardless of case.\nthrows\nAsserts that an exception is an instance of the expected type.\nThe assertion fails if the subject is <code>null<\/code> or not an instance of E.<p>This assertion is designed for use with the strikt.api.catching function.<\/p>\nhas\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nhasSize\nAsserts that a JSON array's size is equal to expected.\nsize\nMaps an assertion on a JSON array to an assertion on its size.\nisBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\nisEmpty\nAsserts that a <code>com.google.protobuf.Any<\/code> is empty and does not contain an\nobject of any kind.\nunpacksTo\nAsserts that the subject is a message of type T.\nunpack\nMaps an assertion on <code>com.google.protobuf.Any<\/code> to an assertion on an unpacked\nmessage of type T.\nisCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
                }]
              }},
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "Assertion",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/Assertion"
                },
                "description": "",
                "title": "Assertion",
                "content": "<p>Allows assertion implementations to determine a result.<\/p>\n<p>pass\nMark this result as passed.\nfail\nMark this result as failed.<\/p>\n"
              }]
            },
            "DescribeableBuilder": {
              "ownKey": "DescribeableBuilder",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "DescribeableBuilder",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/DescribeableBuilder"
                },
                "description": "",
                "title": "DescribeableBuilder",
                "content": "<p>Extension of Assertion.Builder that enables the description of the\nassertion subject.<p>Since it doesn't make sense to do this anywhere except directly after the\ninitial expectThat or Assertion.Builder.get call those methods return an\ninstance of this interface, while assertions themselves just return\nAssertion.Builder.<\/p><\/p>\n<p>describedAs\nAdds a description to the assertion.\nisNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nhas\nAsserts that the subject node has a field named fieldName.\npath\nMaps the subject node of the assertion builder to the node accessed by\nfieldName.\nisObject\nAsserts that the subject node is a JSON object.\nisArray\nAsserts that the subject node is a JSON array.\nisTextual\nAsserts that the subject node is a JSON text node.\nisNumber\nAsserts that the subject node is a JSON numeric node.\nisBoolean\nAsserts that the subject node is a JSON boolean node.\nisMissing\nAsserts that the subject node is a JSON missing node.\ntextValue\nMaps the assertion to an assertion on the subject node's text value.<p>Be aware that if the node is not a text node this will map to an assertion on\n<code>null<\/code>.<\/p>\nnumberValue\nMaps the assertion to an assertion on the subject node's number value.<p>Be aware that if the node is not a numeric node this will map to an assertion\non <code>null<\/code>.<\/p>\nbooleanValue\nMaps the assertion to an assertion on the subject node's boolean value.<p>Be aware that if the node is not a boolean node this will map to an assertion\non <code>false<\/code>.<\/p>\nhasNodeType\nAsserts that the subject node's JsonNode.getNodeType method returns\nnodeType.<p>Convenient aliases for this assertion exist for common node types that also\nnarrow the subject type of the resulting assertion builder.<\/p>\nisBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\nisCompatibleWith\nAsserts that the subject is compatible with expected.<p>For example, a subject of <code>application/json;charset=UTF-8<\/code> is <i>compatiblewith<\/i> the media type <code>application/json<\/code>, but not with the media type\n<code>application/x-yaml<\/code>.<\/p>\ncontentTypeIsCompatibleWith\nAsserts that the content type of the subject is compatible with expected.<\/p>\n"
              }]
            },
            "ExpectationBuilder": {
              "ownKey": "ExpectationBuilder",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "ExpectationBuilder",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/ExpectationBuilder"
                },
                "description": "",
                "title": "ExpectationBuilder",
                "content": "<p>Receiver for expect providing functions that define assertion subjects and\ncreate assertion chains or blocks.<\/p>\n<p>that\nStart a chain of assertions over subject.\nthat\nEvaluate a block of assertions over subject.<\/p>\n"
              }]
            },
            "CompoundAssertions": {
              "ownKey": "CompoundAssertions",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "CompoundAssertions",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/CompoundAssertions"
                },
                "description": "",
                "title": "CompoundAssertions",
                "content": "<p>Returned by Assertion.Builder.compose allowing a bridge between evaluation\nof composed assertions and the determination of the overall result in the\n<code>block<\/code> parameter passed to then.<\/p>\n<p>then\nDetermine the overall status of a compound assertion based on the results\nof its child assertions.<\/p>\n"
              }]
            },
            "CompoundAssertion": {
              "ownKey": "CompoundAssertion",
              "ownPages": [{
                "reference": {
                  "path": "strikt/api",
                  "baseUrl": "https://strikt.io",
                  "fileName": "CompoundAssertion",
                  "extension": "html",
                  "usePrettyUrl": true,
                  "link": "https://strikt.io/strikt/api/CompoundAssertion"
                },
                "description": "",
                "title": "CompoundAssertion",
                "content": "<p>An assertion composed of multiple conditions whose overall result is\ndetermined by some aggregation of those conditions' results.\nanyFailed\n<code>true<\/code> if at least one composed assertion failed,\notherwise <code>false<\/code>.\nallFailed\n<code>true<\/code> if all composed assertions failed, otherwise\n<code>false<\/code>.\nanyPassed\n<code>true<\/code> if at least one composed assertion passed,\notherwise <code>false<\/code>.\nallPassed\n<code>true<\/code> if all composed assertions passed, otherwise\n<code>false<\/code>.\npassedCount\nthe number of composed assertions whose status is\nstrikt.api.Status.Passed.\nfailedCount\nthe number of composed assertions whose status is\nstrikt.api.Status.Failed.<\/p>\n"
              }]
            }
          },
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "api",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/api"
            },
            "description": "",
            "title": "strikt.api",
            "content": "<p>catching\nExecutes action, catching and returning any exception that is thrown. If\nno exception is thrown the method returns <code>null<\/code>.\nexpect\nStarts a block of assertions that will all be evaluated regardless of whether\nearlier ones fail.\nThis is the entry-point for the assertion API.\nexpectThat\nStart a chain of assertions over subject.\nThis is the entry-point for the assertion API.\nexpectThat\nEvaluate a block of assertions over subject.\nThis is the entry-point for the assertion API.\nexpectThrows\nAsserts that actionthrows an exception of type E when executed.<\/p>\n"
          }]
        },
        "time": {
          "ownKey": "time",
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "time",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/time"
            },
            "description": "",
            "title": "strikt.time",
            "content": "<p>isBefore\nAsserts that the subject is before expected.\nisAfter\nAsserts that the subject is after expected.\nget\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.\ngetLong\nMaps an assertion on the subject to an assertion on the value of the\nspecified temporal field.<\/p>\n"
          }]
        },
        "assertions": {
          "ownKey": "assertions",
          "ownPages": [{
            "reference": {
              "path": "strikt",
              "baseUrl": "https://strikt.io",
              "fileName": "assertions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/strikt/assertions"
            },
            "description": "",
            "title": "strikt.assertions",
            "content": "<p>isNull\nAsserts that the subject is <code>null<\/code>.\nisNotNull\nAsserts that the subject is not <code>null<\/code>.\nisA\nAsserts that the subject is an instance of T.\nisEqualTo\nAsserts that the subject is equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisEqualTo\nAsserts that the subject is within tolerance of expected.\nisNotEqualTo\nAsserts that the subject is not equal to expected according to the standard\nKotlin <code>==<\/code> operator.\nisSameInstanceAs\nAsserts that the subject is the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\nisNotSameInstanceAs\nAsserts that the subject is not the same instance as expected according to the standard\nKotlin <code>===<\/code> operator.\npropertiesAreEqualTo\nAsserts that all properties of the subject match those of other according\nto either contentEquals in the case of array properties or isEqualTo in\nother cases.<p>Properties are identified using Java beans conventions.<\/p>\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nBooleanArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nByteArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nShortArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nIntArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nLongArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nFloatArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nDoubleArray.contentEquals.\ncontentEquals\nAsserts that the subject's content is equal to that of other according to\nCharArray.contentEquals.\ntoList\nMaps an array to a list to make it possible to use the iterable matchers\nisTrue\nAsserts that the subject is not null and is the boolean value <code>true<\/code>.\nisFalse\nAsserts that the subject is not null and is the boolean value <code>false<\/code>.\nhasLength\nAsserts that the subject has a CharSequence.length of exactly expected.\nisLowerCase\nAsserts that the subject is composed of all lower-case characters.\nisUpperCase\nAsserts that the subject is composed of all upper-case characters.\nstartsWith\nAsserts that the subject starts with the expected character.\nstartsWith\nAsserts that the subject starts with the expected string.\nendsWith\nAsserts that the subject ends with the expected character.\nendsWith\nAsserts that the subject ends with the expected string.\nmatches\nAsserts that the subject is a full match for the expected regular\nexpression.\nmatchesIgnoringCase\nAsserts that the subject is a full match for the expected regular\nexpression regardless of case.\ncontains\nAsserts that the subject contains a match for the expected regular\nexpression.\ncontains\nAsserts that the subject contains the expected substring.\ncontains\nAsserts that the subject range contains the provided element.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontains\nAsserts that all elements are present in the subject.\nThe elements may exist in any order any number of times and the subject may\ncontain further elements that were not specified.\nIf either the subject or elements are empty the assertion always fails.\ncontainsIgnoringCase\nAsserts that the subject contains a match for the expected regular\nexpression regardless of case.\ncontainsIgnoringCase\nAsserts that the subject contains the expected substring regardless of\ncase.\nisNullOrEmpty\nAsserts that the subject is <code>null<\/code> or the empty string.\nisNullOrBlank\nAsserts that the subject is <code>null<\/code>, empty, or contains only whitespace\ncharacters.\nisEmpty\nAsserts that the subject is the empty string.\nisBlank\nAsserts that the subject is empty, or contains only whitespace characters.\nisNotEmpty\nAsserts that the subject is not the empty string (contains at least one\ncharacter).\nisNotBlank\nAsserts that the subject is not blank (contains at least one non-whitespace\ncharacter).\ntrim\nTrims the subject <code>CharSequence<\/code>.\ntrim\nTrims the subject string.\nhasSize\nAsserts that the subject has a Collection.size of exactly expected.\nisSorted\nAsserts that the subject collection is sorted according to the Comparator. Empty collections are considered sorted.\nisGreaterThan\nAsserts that the subject compares greater than expected according to\nKotlin's standard <code>&gt;<\/code> operator.\nisLessThan\nAsserts that the subject compares less than expected according to Kotlin's\nstandard <code>&lt;<\/code> operator.\nisGreaterThanOrEqualTo\nAsserts that the subject compares greater than or equal to expected\naccording to Kotlin's standard <code>&gt;=<\/code> operator.\nisLessThanOrEqualTo\nAsserts that the subject compares less than or equal to expected according\nto Kotlin's standard <code>&lt;=<\/code> operator.\nisIn\nAsserts that the subject is in the expected range.\nmap\nApplies Iterable.map with function to the subject and returns an\nassertion builder wrapping the result.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable.\nfirst\nMaps this assertion to an assertion over the first element in the subject\niterable that matches predicate.\nsingle\nMaps this assertion to an assertion over the single element in the subject\niterable.\nlast\nMaps this assertion to an assertion over the last element in the subject\niterable.\nflatMap\nMaps this assertion to an assertion over a flattened list of the results of\ntransform for each element in the subject iterable.\nfilter\nMaps this assertion to an assertion over a list of all elements of the subject that match <code>predicate<\/code>.\nfilterNot\nMaps this assertion to an assertion over a list of all elements of the subject that do not match <code>predicate<\/code>.\nfilterIsInstance\nMaps this assertion to an assertion over a list of all elements of the subject that are instances of <code>R<\/code>.\nall\nAsserts that all elements of the subject pass the assertions in predicate.\nany\nAsserts that <i>at least one<\/i> element of the subject pass the assertions in\npredicate.\nnone\nAsserts that <i>no<\/i> elements of the subject pass the assertions in predicate.\natLeast\nAsserts that at least count elements of the subject pass the assertions in\npredicate.\natMost\nAsserts that at most count elements of the subject pass the assertions in\npredicate.\nexactly\nAsserts that exactly count elements of the subject pass the assertions in\npredicate.\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ndoesNotContain\nAsserts that none of elements are present in the subject.<p>If elements is empty the assertion always fails.\nIf the subject is empty the assertion always passe.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactly\nAsserts that all elements <i>and no others<\/i> are present in the subject in the\nspecified order.<p>If the subject has no guaranteed iteration order (for example a Set) this\nassertion is probably not appropriate and you should use\ncontainsExactlyInAnyOrder instead.<\/p>\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\ncontainsExactlyInAnyOrder\nAsserts that all elements <i>and no others<\/i> are present in the subject.\nOrder is not evaluated, so an assertion on a List will pass so long as it\ncontains all the same elements with the same cardinality as elements\nregardless of what order they appear in.\nget\nMaps this assertion to an assertion on the element at index i in the\nsubject list.\nget\nMaps this assertion to an assertion on the elements at the sub-list\nrepresented by range in the subject list.\nget\nMaps this assertion to an assertion on the value indexed by key in the\nsubject list.\ngetValue\nAsserts that key exists in the subject map and then maps this assertion to\nan assertion on the associated value.\ncontainsKey\nAsserts that the subject map contains an entry indexed by key. Depending on\nthe map implementation the value associated with key may be <code>null<\/code>. This\nassertion just tests for the existence of the key.\ncontainsKeys\nAsserts that the subject map contains entries for all keys.\nhasEntry\nAsserts that the subject map contains an entry indexed by key with a value\nequal to value.\nisPresent\nAsserts that an <code>Optional<\/code> contains a value (is not empty) and returns an\nassertion builder whose subject is the value.\nisAbsent\nAsserts that an <code>Optional<\/code> does not contain a value.\ntoNullable\nMaps an assertion on a Java <code>Optional<\/code> to a Kotlin nullable type.\nisEqualToIgnoringCase\nAsserts that the subject is equal to the expected value regardless of case.\nthrows\nAsserts that an exception is an instance of the expected type.\nThe assertion fails if the subject is <code>null<\/code> or not an instance of E.<p>This assertion is designed for use with the strikt.api.catching function.<\/p><\/p>\n"
          }]
        }
      }
    },
    "wiki": {
      "ownKey": "wiki",
      "childrenPages": {
        "custom-assertions": {
          "ownKey": "custom-assertions",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "custom-assertions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/custom-assertions"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "additional-modules",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/additional-modules"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "grouping-with-and",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/grouping-with-and"
            },
            "description": "",
            "title": "Custom Assertions",
            "content": "<h1 id=\"custom-assertions\">Custom Assertions<\/h1>\n<p>One of the aims of Strikt is that implementing your own assertions is <em>really, really<\/em> easy.\nAssertion functions are <a href=\"https://kotlinlang.org/docs/reference/extensions.html\">extension functions<\/a> on the interface <code>Assertion.Builder&lt;T&gt;<\/code> where <code>T<\/code> is the type of the assertion subject.<\/p>\n<h3 id=\"tip-avoiding-clashing-method-signatures\">Tip: Avoiding clashing method signatures<\/h3>\n<p>Because of Java's generic type erasure, it's possible that the name of your custom assertion function may clash with an existing one for a different subject type.<\/p>\n<p>To avoid this you can add the <code>@JvmName<\/code> annotation to your assertion function to disambiguate the methods.\nSee <a href=\"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#handling-signature-clashes-with-jvmname\">Handling signature clashes with <em>@JvmName<\/em><\/a> in the Kotlin documentation.<\/p>\n<p>For example, if you were defining an <code>isEmpty<\/code> assertion for Gson's <code>JsonArray<\/code> type, you would need to disambiguate it from the <code>isEmpty<\/code> assertion Strikt provides for collections.<\/p>\n<pre><code class=\"language-kotlin\">@JvmName(&quot;isEmpty_JsonArray&quot;)\nfun Assertion.Builder&lt;JsonArray&gt;.isEmpty(): Assertion.Builder&lt;JsonArray&gt; =\n  // ...\n<\/code><\/pre>\n<h2 id=\"atomic-assertions\">Atomic assertions<\/h2>\n<p>&quot;Atomic&quot; assertions produce a single message on failure.\nThey call <code>assert<\/code> passing a lambda with the assertion logic that calls <code>pass()<\/code> or <code>fail()<\/code>.<\/p>\n<p>The standard assertions <code>isNull<\/code>, <code>isEqualTo<\/code>, <code>isA&lt;T&gt;<\/code> and many others are simple assertions implemented just like this.<\/p>\n<p>Let's imagine we're implementing an assertion function for <code>java.time.LocalDate<\/code> that tests if the represented date is a leap day.<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assert(&quot;is St. Tib&#39;s Day&quot;) {\n    when (MonthDay.from(it)) {\n      MonthDay.of(2, 29) -&gt; pass()\n      else -&gt; fail()\n    }\n  }<\/code><\/pre>\n<p>Breaking this down:<\/p>\n<ol>\n<li>We declare the assertion function applies only to <code>Assertion.Builder&lt;LocalDate&gt;<\/code>.<\/li>\n<li>Note that the function also returns <code>Assertion.Builder&lt;LocalDate&gt;<\/code> so we can include this assertion as part of a chain.<\/li>\n<li>We call <code>assert<\/code> passing a description of the assertion and a lambda with the assertion logic.<\/li>\n<li>If <code>it<\/code> (the test subject) is the value we want we call <code>pass()<\/code> otherwise we call <code>fail()<\/code><\/li>\n<\/ol>\n<p>If this assertion fails it will produce a message like:<\/p>\n<pre><code class=\"language-text\">▼ Expect that 2018-05-01:\n  ✗ is St. Tib&#39;s Day<\/code><\/pre>\n<h3 id=\"note\">Note<\/h3>\n<p>The method <code>assert<\/code> accepts a description for the assertion being made and a lambda function <code>Assertion&lt;T&gt;.(T) -&gt; Unit<\/code>.\nThe parameter passed to the lambda is the assertion subject.\nThe <code>Assertion&lt;T&gt;<\/code> receiver provides the lambda the <code>pass()<\/code> and <code>fail()<\/code> methods for reporting the assertion result.<\/p>\n<h2 id=\"describing-the-actual-value\">Describing the &quot;actual&quot; value<\/h2>\n<p>For assertions that perform a comparison between actual and expected values it is usually helpful to describe the value that was incorrect.\nThat way any assertion failure message will be more helpful.<\/p>\n<p>In order to do this, Strikt provides an overridden version of <code>fail()<\/code> that accepts a message string and the actual value found.\nThe message string should contain a format placeholder for the value.<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assert(&quot;is St. Tib&#39;s Day&quot;) {\n    when (MonthDay.from(it)) {\n      MonthDay.of(2, 29) -&gt; pass()\n      else -&gt; fail(\n        description = &quot;in fact it is %s&quot;,\n        actual = it\n      )\n    }\n  }<\/code><\/pre>\n<p>Now if the assertion fails there is a little more detail.<\/p>\n<pre><code class=\"language-text\">▼ Expect that 2018-05-01:\n  ✗ is St. Tib&#39;s Day : in fact it is 2018-05-01<\/code><\/pre>\n<p>In this case that's not terribly helpful but when dealing with properties, method return values, or the like it can save a lot of effort in identifying the precise cause of an error.\nWhen comparing large string values it also means IDEs such as IntelliJ IDEA will present a detailed diff dialog in the event of a test failure.<\/p>\n<h2 id=\"simple-atomic-assertions-with-boolean-expressions\">Simple atomic assertions with boolean expressions<\/h2>\n<p>For the simplest assertion functions, instead of using <code>assert<\/code> and calling <code>pass<\/code> or <code>fail<\/code>, you can use <code>assertThat<\/code> with a lambda whose parameter is the assertion subject that returns a boolean.<\/p>\n<p>We can re-implement the example above like this:<\/p>\n<pre><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay(): Assertion.Builder&lt;LocalDate&gt; =\n  assertThat(&quot;is St. Tib&#39;s Day&quot;) {\n    MonthDay.from(it) == MonthDay.of(2, 29)\n  }<\/code><\/pre>\n<p>You should not use this form when you want to provide a meaningful description of the actual value but for simple assertions it's slightly less verbose.<\/p>\n<h2 id=\"composed-assertions\">Composed assertions<\/h2>\n<p>For more complex assertion implementations you can &quot;nest&quot; sub-assertions inside your overall assertion.\nComposed assertions' results are reported under the overall result which is useful for providing detailed diagnostic information in case of a failure.<\/p>\n<p>Composed assertions are useful for things like:<\/p>\n<ul>\n<li>applying assertions to multiple properties of an object, for example for a field-by-field comparison.<\/li>\n<li>applying assertions to all elements of a collection or entries in a map, reporting on individual elements.<\/li>\n<\/ul>\n<p>Imagine we're creating an assertion function that tests fails if any element of a collection is <code>null<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">fun &lt;T : Iterable&lt;E?&gt;, E&gt; Assertion.Builder&lt;T&gt;.containsNoNullElements(): Assertion.Builder&lt;T&gt; =\n  compose(&quot;does not contain any null elements&quot;) { subject -&gt;\n    subject.forEach { element -&gt;\n      get(&quot;%s&quot;) { element }.isNotNull()\n    }\n  } then {\n    if (allPassed) pass() else fail()\n  }<\/code><\/pre>\n<p>Breaking this down:<\/p>\n<ol>\n<li>We declare the overall assertion function applies to an <code>Iterable<\/code> of a nullable element type <code>E<\/code>.<\/li>\n<li>We use the <code>compose<\/code> method instead of <code>assert<\/code>.<\/li>\n<li>Inside the <code>compose<\/code> block we make assertions about each element of the iterable subject.<\/li>\n<li>Inside the <code>then<\/code> block we pass or fail the overall assertion depending on whether the nested assertions all passed.<\/li>\n<\/ol>\n<p>The receiver of the block passed to <code>result<\/code> has the properties <code>allFailed<\/code>, <code>anyFailed<\/code>, <code>allPassed<\/code> and <code>anyPassed<\/code> along with <code>pass()<\/code> and <code>fail()<\/code> functions used in simple assertions.<\/p>\n<p>If the assertion failed we'll see something like this:<\/p>\n<pre><code class=\"language-text\">▼ Expect that [&quot;catflap&quot;, null, &quot;rubberplant&quot;, &quot;marzipan&quot;]:\n  ✗ does not contain any null elements\n    ▼ &quot;catflap&quot;:\n      ✓ is not null\n    ▼ null:\n      ✗ is not null\n    ▼ &quot;rubberplant&quot;:\n      ✓ is not null\n    ▼ &quot;marzipan&quot;:\n      ✓ is not null<\/code><\/pre>\n<p>As well as the overall assertion failure message we get a detailed breakdown allowing us to easily find exactly where the problem is.<\/p>\n<p>Several assertion functions in Strikt's standard assertions library use nested assertions.\nFor example, <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.all<\/code> applies assertions to each element of an <code>Iterable<\/code> then passes the overall assertion if (and only if) all those nested assertions passed (<code>allPassed<\/code>).\nOn the other hand <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.any<\/code> applies assertions to the elements of an <code>Iterable<\/code> but will pass the overall assertion if at least one of those nested assertions passed (<code>anyPassed<\/code>).\nThe <code>Assertion.Builder&lt;Iterable&lt;E&gt;&gt;.none<\/code> assertion passes only if <code>allFailed<\/code> is true for its nested assertions!<\/p>\n"
          }]
        },
        "getting-started": {
          "ownKey": "getting-started",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "getting-started",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/getting-started"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "assertion-styles",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/assertion-styles"
            },
            "description": "",
            "title": "Getting Started",
            "content": "<h1 id=\"getting-started\">Getting Started<\/h1>\n<p>Strikt does not depend on any particular test runner.\nIt can be used with JUnit, Spek or any other runner that supports tests written in Kotlin.<\/p>\n<h2 id=\"installation\">Installation<\/h2>\n<p>Strikt is available from JCenter.\nAdd the following to your <code>build.gradle<\/code> or <code>build.gradle.kts<\/code>.<\/p>\n<pre><code class=\"language-kotlin\">repositories {\n  jcenter()\n}\n\ndependencies {\n  testImplementation(&quot;io.strikt:strikt-core:0.19.6&quot;)\n}\n<\/code><\/pre>\n<h2 id=\"importing-the-strikt-api\">Importing the Strikt API<\/h2>\n<p>Add the following imports to your test:<\/p>\n<pre><code class=\"language-kotlin\">import strikt.api.*\nimport strikt.assertions.*\n<\/code><\/pre>\n<p>The <code>strikt.api<\/code> package contains top level functions such as <code>expect<\/code>, <code>expectThat<\/code>, and <code>expectThrows<\/code> that you will use to create assertions as well as the API classes you will interact with if you decide to implement your own assertion functions.\nThe <code>strikt.assertions<\/code> package contains the standard library of assertion functions.<\/p>\n"
          }]
        },
        "additional-modules": {
          "ownKey": "additional-modules",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "additional-modules",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/additional-modules"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "custom-assertions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/custom-assertions"
            },
            "description": "",
            "title": "Additional Modules",
            "content": "<h1 id=\"additional-modules\">Additional Modules<\/h1>\n<p>In addition to the core functionality provided by the <code>strikt-core<\/code> module, Strikt has the following optional modules:<\/p>\n<h2 id=\"jackson\">Jackson<\/h2>\n<p>Extensions for assertions and traversals on types <a href=\"https://github.com/FasterXML/jackson\">Jackson<\/a>'s <code>JsonNode<\/code> and sub-types.\nSee the <a href=\"https://strikt.io/strikt/jackson\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-jackson:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"java-time\">Java Time<\/h2>\n<p>Extensions for assertions and traversals on types from the <code>java.time<\/code> package.\nSee the <a href=\"https://strikt.io/strikt/time\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-java-time:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"protobuf\">Protobuf<\/h2>\n<p>Extensions for testing code that uses Protobuf / gRPC.\nSee the <a href=\"https://strikt.io/strikt/protobuf\">API docs<\/a>.<\/p>\n<p>Add the following to your dependencies:<\/p>\n<pre><code class=\"language-kotlin\">testImplementation(&quot;io.strikt:strikt-protobuf:0.19.6&quot;)\n<\/code><\/pre>\n<h2 id=\"using-the-bill-of-materials-bom\">Using the Bill of Materials (BOM)<\/h2>\n<p>If you're using multiple Strikt modules (and Gradle &gt;= 5.0) you can import Strikt's BOM and then omit versions for individual modules.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">dependencies {\n  testImplementation(platform(&quot;io.strikt:strikt-bom:0.19.6&quot;))\n  testImplementation(&quot;io.strikt:strikt-jackson&quot;)\n  testImplementation(&quot;io.strikt:strikt-java-time&quot;)\n}\n<\/code><\/pre>\n"
          }]
        },
        "expecting-exceptions": {
          "ownKey": "expecting-exceptions",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "expecting-exceptions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/expecting-exceptions"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "flow-typing",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/flow-typing"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "collection-elements",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/collection-elements"
            },
            "description": "",
            "title": "Expecting Exceptions",
            "content": "<h1 id=\"asserting-exceptions-are-thrown\">Asserting exceptions are thrown<\/h1>\n<p>To assert that some code throws an exception you can use the <code>catching<\/code> function that accepts a lambda <code>() -&gt; Unit<\/code> that performs the operation that should throw an exception and the <code>throws&lt;E&gt;<\/code> assertion function.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(catching { identifyHotdog(&quot;hamburger&quot;) })\n  .throws&lt;NotHotdogException&gt;()<\/code><\/pre>\n<p>The <code>catching<\/code> function returns <code>Throwable?<\/code> with the value being whatever exception is thrown by the lambda, or <code>null<\/code> if nothing is thrown.\nCombining it with the <code>throws&lt;E&gt;<\/code> assertion allows testing for specific exception types.\nThe <code>throws&lt;E&gt;<\/code> assertion will fail if the exception is <code>null<\/code> or the wrong type.<\/p>\n<p>The <code>throws&lt;E&gt;<\/code> function returns an <code>Assertion.Builder&lt;E&gt;<\/code> so you can chain assertions about the exception itself after it.<\/p>\n<p>If you just need to test that <em>any<\/em> exception was or was not thrown you can combine <code>catching<\/code> with <code>isNull<\/code> or <code>isNotNull<\/code>.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(catching { identifyHotdog(&quot;hotdog&quot;) })\n  .isNull()<\/code><\/pre>\n<h2 id=\"shorthand-form\">Shorthand form<\/h2>\n<p>You can also use the <code>expectThrows&lt;E&gt;(A)<\/code> function which is simply a shorthand for the <code>expectThat<\/code> / <code>catching<\/code> / <code>throws<\/code> combination.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThrows&lt;NotHotdogException&gt; {\n  identifyHotdog(&quot;hamburger&quot;)\n}<\/code><\/pre>\n"
          }]
        },
        "grouping-with-and": {
          "ownKey": "grouping-with-and",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "grouping-with-and",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/grouping-with-and"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "custom-assertions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/custom-assertions"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "traversing-subjects",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/traversing-subjects"
            },
            "description": "",
            "title": "Grouping Assertions With and",
            "content": "<h1 id=\"grouping-assertions-with-and\">Grouping Assertions with <em>and<\/em><\/h1>\n<p>Strikt provides the <code>and<\/code> method that is used to add a block of assertions to a chain.\nThis is useful in a couple of scenarios.<\/p>\n<h2 id=\"grouping-assertions-after-a-null-or-type-check\">Grouping assertions after a null or type check<\/h2>\n<p>It's frequently useful to be able to perform a block of assertions after narrowing the subject type.\nFor example, if the declared type of an assertion subject is nullable it can be awkward to apply a block of assertions directly with <code>expectThat<\/code> as every individual assertion in the block needs to deal with the nullable type.<\/p>\n<p>The same is true when the subject type is overly broad and you need to narrow the type with <code>isA&lt;T&gt;<\/code> in order to use assertion functions that are specific to the runtime type.<\/p>\n<p>The <code>and<\/code> method is helpful in these scenarios.\nFor example:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(subject)\n  .isNotNull()\n  .and {\n    // perform other assertions on a known non-null subject\n  }<\/code><\/pre>\n<p>The type after <code>expectThat<\/code> is <code>Assertion.Builder&lt;T?&gt;<\/code> (assuming <code>subject<\/code> has a nullable declared type) but the receiever of <code>and<\/code> is <code>Assertion.Builder&lt;T&gt;<\/code> as <code>isNotNull<\/code> has narrowed the subject type.<\/p>\n<h2 id=\"making-assertions-on-sub-trees-of-a-subject\">Making assertions on sub-trees of a subject<\/h2>\n<p>Another use for <code>and<\/code> is to create a branch of assertions that apply to a sub-tree of the subject.\nFor example, if testing a complex value type with nested properties:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(person)\n  .and {\n    get { name }.isEqualTo(&quot;David&quot;)\n  }\n  .and {\n    get { birthDate.year }.isEqualTo(1947)\n  }<\/code><\/pre>\n<p>Of course, it may be better to structure the same assertion with separate assertions.\nThis is a lot more readable:<\/p>\n<pre><code class=\"language-kotlin\">expect {\n  that(person.name).isEqualTo(&quot;David&quot;)\n  that(person.birthDate.year).isEqualTo(1947)\n}<\/code><\/pre>\n<p>Testing properties of a collection can be done in a similar way:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(albums)\n  .hasSize(26)\n  .and { first().get { name }.isEqualTo(&quot;David Bowie&quot;) }\n  .and { last().get { name }.isEqualTo(&quot;Blackstar&quot;) }<\/code><\/pre>\n"
          }]
        },
        "collection-elements": {
          "ownKey": "collection-elements",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "collection-elements",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/collection-elements"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "expecting-exceptions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/expecting-exceptions"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "assertion-styles",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/assertion-styles"
            },
            "description": "",
            "title": "Collection Element Assertions",
            "content": "<h1 id=\"assertions-on-elements-of-a-collection\">Assertions on elements of a collection<\/h1>\n<p>Some assertions on collections include sub-assertions applied to the elements of the collection.\nFor example, we can assert that <em>all<\/em> elements conform to a repeated assertion.<\/p>\n<pre><code class=\"language-kotlin\">val subject = setOf(&quot;catflap&quot;, &quot;rubberplant&quot;, &quot;marzipan&quot;)\nexpectThat(subject).all {\n  isLowerCase()\n  startsWith(&#39;c&#39;)\n}<\/code><\/pre>\n<p>This produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that [&quot;catflap&quot;, &quot;rubberplant&quot;, &quot;marzipan&quot;]:\n  ✗ all elements match:\n    ▼ &quot;catflap&quot;:\n      ✓ is lower case\n      ✓ starts with &#39;c&#39;\n    ▼ &quot;rubberplant&quot;:\n      ✓ is lower case\n      ✗ starts with &#39;c&#39; : found &#39;r&#39;\n    ▼ &quot;marzipan&quot;:\n      ✓ is lower case\n      ✗ starts with &#39;c&#39; : found &#39;m&#39;<\/code><\/pre>\n<p>The results are broken down by individual elements in the collection so it's easy to see which failed.<\/p>\n<p>Similarly, <code>any<\/code> asserts that at least one element passes the nested assertions and <code>none<\/code> succeeds if all elements of the collection <em>fail<\/em> the nested assertions.<\/p>\n"
          }]
        },
        "flow-typing": {
          "ownKey": "flow-typing",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "flow-typing",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/flow-typing"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "traversing-subjects",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/traversing-subjects"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "expecting-exceptions",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/expecting-exceptions"
            },
            "description": "",
            "title": "Strongly Typed Assertions",
            "content": "<h1 id=\"strongly-typed-assertions\">Strongly Typed Assertions<\/h1>\n<p>Strikt's API is designed to work with Kotlin's strong type system.<\/p>\n<p>Strikt's assertion API uses the interface <code>Assertion.Builder&lt;T&gt;<\/code>, with the generic type <code>T<\/code> representing the (declared) type of the assertion subject.\nAssertion functions such as <code>isEqualTo<\/code> are implemented as extension functions on <code>Assertion.Builder<\/code> with an appropriate generic type.<\/p>\n<p>For example <code>isEqualTo<\/code> is an extension function on <code>Assertion.Builder&lt;Any?&gt;<\/code> as it's useful for many types of subject whereas <code>isEqualToIgnoringCase<\/code> is an extension function on <code>Assertion.Builder&lt;CharSequence&gt;<\/code> since it only makes sense to use it on string-like things.<\/p>\n<p>Some assertion functions will return an <code>Assertion.Builder<\/code> with a <em>different<\/em>, more specific, generic type to the one they were called on.<\/p>\n<h2 id=\"nullable-subjects\">Nullable subjects<\/h2>\n<p>For example, if the subject of an assertion is a nullable type (in other words it's an <code>Assertion.Builder&lt;T?&gt;<\/code>) the assertion methods <code>isNull()<\/code> and <code>isNotNull()<\/code> are available.\nThe return type of <code>isNotNull()<\/code> is <code>Assertion.Builder&lt;T&gt;<\/code> because we now <em>know<\/em> the subject is not null.\nYou will find IDE code-completion will no longer offer the <code>isNull()<\/code> and <code>isNotNull()<\/code> assertion methods.<\/p>\n<h2 id=\"narrowing-assertions\">Narrowing assertions<\/h2>\n<p>Another example is making assertions about a subject's specific runtime type, or &quot;narrowing&quot;.<\/p>\n<p>For example:<\/p>\n<pre><code class=\"language-kotlin\">val subject: Map&lt;String, Any&gt; = mapOf(&quot;count&quot; to 1, &quot;name&quot; to &quot;Rob&quot;)\nexpectThat(subject[&quot;count&quot;])\n  .isA&lt;Int&gt;()\n  .isGreaterThan(0)\n\nexpectThat(subject[&quot;name&quot;])\n  .isA&lt;String&gt;()\n  .hasLength(3)<\/code><\/pre>\n<p>The return type of the subject map's <code>get()<\/code> method is <code>Any<\/code> but using the narrowing assertion <code>isA&lt;T&gt;()<\/code> we can both assert the type of the value and, because the compiler now knows it is dealing with an <code>Assertion.Builder&lt;String&gt;<\/code> or an <code>Assertion.Builder&lt;Number&gt;<\/code>, we can use more specialized assertion methods that are only available for those subject types.<\/p>\n<p>Without the <code>isA&lt;T&gt;()<\/code> assertion the code would not compile:<\/p>\n<pre><code class=\"language-kotlin\">val subject: Map&lt;String, Any&gt; = mapOf(&quot;count&quot; to 1, &quot;name&quot; to &quot;Rob&quot;)\nexpectThat(subject.get(&quot;count&quot;))\n  .isGreaterThan(0) \n  // isGreaterThan does not exist on Assertion.Builder&lt;Any&gt;\n  \nexpectThat(subject.get(&quot;name&quot;))\n  .hasLength(3) \n  // hasLength does not exist on Assertion.Builder&lt;Any&gt;\n<\/code><\/pre>\n<p>This mechanism means that IDE code-completion is optimally helpful as only assertion methods that are appropriate to the subject type will be suggested.<\/p>\n"
          }]
        },
        "assertion-styles": {
          "ownKey": "assertion-styles",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "assertion-styles",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/assertion-styles"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "collection-elements",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/collection-elements"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "getting-started",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/getting-started"
            },
            "description": "",
            "title": "Assertion Styles",
            "content": "<h1 id=\"assertion-styles\">Assertion styles<\/h1>\n<p>Two different styles of assertion -- chained and block -- are supported for different use-cases.\nYou can mix and match both in the same test and even nest chained assertions inside block assertions.<\/p>\n<h2 id=\"chained-assertions\">Chained assertions<\/h2>\n<p>Chained assertions use a fluent API similar to AssertJ.\nThey fail fast.\nThat is, the first assertion that fails breaks the chain and further assertions are not evaluated.<\/p>\n<p>Each assertion in the chain returns an <code>Assertion.Builder<\/code> object that supports further assertions.<\/p>\n<pre><code class=\"language-kotlin\">val subject = &quot;fnord&quot;\nexpectThat(subject)\n  .isA&lt;String&gt;()\n  .hasLength(1)\n  .isUpperCase()<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that &quot;fnord&quot;:\n  ✓ is an instance of java.lang.String\n  ✗ has length 1 : found 5<\/code><\/pre>\n<p>Notice that the <code>isUpperCase()<\/code> assertion is not applied as the earlier <code>hasLength(1)<\/code> assertion failed.<\/p>\n<h2 id=\"block-assertions\">Block assertions<\/h2>\n<p>Block assertions are declared in a lambda whose receiver is an <code>Assertion.Builder&lt;T&gt;<\/code> object.\nThey allow multiple assertions (or assertion chains) to be evaluated against the subject.<\/p>\n<p>Block assertions do <em>not<\/em> fail fast.\nThat is, all assertions in the block are evaluated and the result of the &quot;compound&quot; assertion will include results for all the assertions made in the block.<\/p>\n<pre><code class=\"language-kotlin\">val subject = &quot;fnord&quot;\nexpectThat(subject) {\n  isA&lt;String&gt;()\n  hasLength(1)\n  isUpperCase()\n}<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that &quot;fnord&quot;:\n  ✓ is an instance of java.lang.String\n  ✗ has length 1 : found 5\n  ✗ is upper case<\/code><\/pre>\n<p>All assertions are applied and since two fail there are two errors logged.<\/p>\n<h3 id=\"chained-assertions-inside-block-assertions\">Chained assertions inside block assertions<\/h3>\n<p>Chained assertions inside a block <em>will<\/em> still fail fast but will not prevent other assertions in the block from being evaluated.<\/p>\n<pre><code class=\"language-kotlin\">val subject = 1L\nexpectThat(subject) {\n  isLessThan(1L).isA&lt;Int&gt;()\n  isGreaterThan(1L)\n}<\/code><\/pre>\n<p>Produces the output:<\/p>\n<pre><code class=\"language-text\">▼ Expect that 1:\n  ✗ is less than 1\n  ✗ is greater than 1<\/code><\/pre>\n<p>Note the <code>isA&lt;Int&gt;<\/code> assertion (that would have failed) was not evaluated since it was chained after <code>lessThan(1)<\/code> which failed.\nThe <code>greaterThan(1)<\/code> assertion <em>was<\/em> evaluated since it was not part of the same chain.<\/p>\n<h2 id=\"assertions-with-multiple-subjects\">Assertions with multiple subjects<\/h2>\n<p>As well as <code>expectThat<\/code> Strikt provides a top-level <code>expect<\/code> method that just takes a lambda parameter.\nInside the <code>expect<\/code> block you use <code>that<\/code> to define a subject and start a chain or nested block of assertions.<\/p>\n<p>All assertions inside the <code>expect<\/code> lambda are evaluated.<\/p>\n<p>The previous examples can be combined into a single <code>expect<\/code> block.<\/p>\n<pre><code class=\"language-kotlin\">expect {\n  that(&quot;fnord&quot;)\n    .isA&lt;String&gt;()\n    .hasLength(1)\n    .isUpperCase()\n  that(1L) {\n    isLessThan(1L).isA&lt;Int&gt;()\n    isGreaterThan(1L)\n  }\n}<\/code><\/pre>\n"
          }]
        },
        "traversing-subjects": {
          "ownKey": "traversing-subjects",
          "ownPages": [{
            "reference": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "traversing-subjects",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/traversing-subjects"
            },
            "next": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "grouping-with-and",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/grouping-with-and"
            },
            "previous": {
              "path": "wiki",
              "baseUrl": "https://strikt.io",
              "fileName": "flow-typing",
              "extension": "html",
              "usePrettyUrl": true,
              "link": "https://strikt.io/wiki/flow-typing"
            },
            "description": "",
            "title": "Traversing Assertion Subjects",
            "content": "<h1 id=\"traversing-assertion-subjects\">Traversing Assertion Subjects<\/h1>\n<p>Although you can obviously write assertions for the properties of an object with code like this:<\/p>\n<pre><code class=\"language-kotlin\">expectThat(map.size).isEqualTo(1)\nexpectThat(list.first()).isEqualTo(&quot;fnord&quot;)\nexpectThat(person.name).isEqualTo(&quot;Ziggy&quot;)<\/code><\/pre>\n<p>Sometimes it's useful to be able to transform an assertion on a subject to an assertion on a property of that subject, or the result of a method call.\nParticularly when using soft assertion blocks.<\/p>\n<p>Strikt allows for this using the <code>Assertion.Builder&lt;T&gt;.get<\/code> method.<\/p>\n<h2 id=\"using-get-with-lambdas\">Using <em>get<\/em> with lambdas<\/h2>\n<p>The method takes a lambda whose receiver is the current subject and returns an <code>Assertion.Builder&lt;R&gt;<\/code> where <code>R<\/code> (the new subject) is the type of whatever the lambda returns.<\/p>\n<p>This is useful for making assertions about the properties of an object or the values returned by methods, particularly if you want to use a block-style assertion to validate multiple object properties.<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  get { name }.isEqualTo(&quot;Ziggy&quot;)\n  get { birthDate.year }.isEqualTo(1971)\n}<\/code><\/pre>\n<p>Strikt will read the test source to find out the name of the variables.\nThis example produces output that looks like this:<\/p>\n<pre><code class=\"language-text\">▼ Expect that Person(name=David, birthDate=1947-01-08):\n  ▼ name:\n    ✗ is equal to &quot;Ziggy&quot; : found &quot;David&quot;\n  ▼ birthDate.year:\n    ✗ is equal to 1971 : found 1947<\/code><\/pre>\n<h2 id=\"using-get-with-property-or-method-references\">Using <em>get<\/em> with property or method references<\/h2>\n<p>It's also possible to use a property or method reference in place of a lambda.<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  get(Person::name).isEqualTo(&quot;David&quot;)\n  get(Person::birthDate).get(LocalDate::getYear).isEqualTo(1947)\n}<\/code><\/pre>\n<h2 id=\"mapping-elements-of-collections\">Mapping elements of collections<\/h2>\n<p>If the assertion subject is an <code>Iterable<\/code> Strikt provides a <code>map<\/code> function much like the one in the Kotlin standard library.\nIt is effectively like using <code>get<\/code> on each element of the <code>Iterable<\/code> subject.<\/p>\n<pre><code class=\"language-kotlin\">val subject: List&lt;Person&gt; = getPersonList()\nexpectThat(subject)\n  .map(Person::name)\n  .containsExactly(&quot;David&quot;, &quot;Ziggy&quot;, &quot;Aladdin&quot;, &quot;Jareth&quot;)<\/code><\/pre>\n<p>In this case the <code>map<\/code> function is transforming the <code>Assertion.Buidler&lt;List&lt;Person&gt;&gt;<\/code> into an <code>Assertion.Builder&lt;List&lt;String&gt;&gt;<\/code> by applying the <code>name<\/code> property to each element.<\/p>\n<h2 id=\"re-usable-mapping-extensions\">Re-usable mapping extensions<\/h2>\n<p>If you find yourself frequently using <code>get<\/code> for the same properties or methods, consider defining extension property or method to make things even easier.<\/p>\n<p>For example:<\/p>\n<pre><code class=\"language-kotlin\">val Assertion.Builder&lt;Person&gt;.name: Assertion.Builder&lt;String&gt;\n  get() = get(Person::name)\n\nval Assertion.Builder&lt;Person&gt;.yearOfBirth: Assertion.Builder&lt;Int&gt;\n  get() = get(&quot;year of birth&quot;) { birthDate.year }<\/code><\/pre>\n<p>You can then write the earlier example as:<\/p>\n<pre><code class=\"language-kotlin\">val subject = Person(name = &quot;David&quot;, birthDate = LocalDate.of(1947, 1, 8))\nexpectThat(subject) {\n  name.isEqualTo(&quot;David&quot;)\n  yearOfBirth.isEqualTo(1947)\n}<\/code><\/pre>\n<h2 id=\"built-in-traversals\">Built-in traversals<\/h2>\n<p>Strikt has a number of built in traversal properties and functions such as <code>Assertion.Builder&lt;List&lt;E&gt;&gt;.first()<\/code> which returns an <code>Assertion.Builder&lt;E&gt;<\/code> whose subject is the first element of the list.\nSee the <a href=\"https://strikt.io/strikt/assertions\">API docs<\/a> for details.<\/p>\n"
          }]
        }
      },
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://strikt.io",
          "fileName": "wiki",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://strikt.io/wiki"
        },
        "description": "",
        "title": "Wiki",
        "content": "<html>\n <head><\/head>\n <body>\n  <ul> \n   <li><a href=\"https://strikt.io/wiki/getting-started\">Getting Started<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/assertion-styles\">Assertion Styles<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/collection-elements\">Collection Element Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/expecting-exceptions\">Expecting Exceptions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/flow-typing\">Strongly Typed Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/traversing-subjects\">Traversing Assertion Subjects<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/grouping-with-and\">Grouping Assertions With and<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/custom-assertions\">Custom Assertions<\/a><\/li> \n   <li><a href=\"https://strikt.io/wiki/additional-modules\">Additional Modules<\/a><\/li> \n  <\/ul> \n <\/body>\n<\/html>\n"
      }]
    },
    "about": {
      "ownKey": "about",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://strikt.io",
          "fileName": "about",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://strikt.io/about"
        },
        "description": "",
        "title": "About Strikt",
        "content": "<h1 id=\"about-strikt\">About Strikt<\/h1>\n<p>Strikt was written by <a href=\"https://github.com/robfletcher\">Rob Fletcher<\/a> with contributions from:<\/p>\n<ul>\n<li><a href=\"https://github.com/sandjelkovic\">Stefan Anđelković<\/a><\/li>\n<li><a href=\"https://github.com/cjbrooks12\">Casey Brooks<\/a><\/li>\n<li><a href=\"https://github.com/adrielcafe\">Adriel Café<\/a><\/li>\n<li><a href=\"https://github.com/xhanin\">Xavier Hanin<\/a><\/li>\n<li><a href=\"https://github.com/mkobit\">Mike Kobit<\/a><\/li>\n<li><a href=\"https://github.com/eskatos\">Paul Merlin<\/a><\/li>\n<li><a href=\"https://github.com/christophsturm\">Christoph Sturm<\/a><\/li>\n<li><a href=\"https://github.com/DanielThomas\">Danny Thomas<\/a><\/li>\n<\/ul>\n<h2 id=\"license\">License<\/h2>\n<p>Strikt is licensed under the <a href=\"https://www.apache.org/licenses/LICENSE-2.0.html\">Apache License v2.0<\/a>.<\/p>\n<h2 id=\"contributing\">Contributing<\/h2>\n<p>Suggestions and contributions are welcome.<\/p>\n<ul>\n<li><strong>Issues<\/strong>: You can discuss and raise issues on <a href=\"https://github.com/robfletcher/strikt/issues\">GitHub<\/a>.<\/li>\n<li><strong>Slack<\/strong>: Join the <a href=\"https://kotlinlang.slack.com/messages/CAR7KJ96J\"><strong>#strikt<\/strong><\/a> channel on the Kotlin Slack.<\/li>\n<li><strong>Twitter<\/strong>: Follow <a href=\"https://twitter.com/stri_kt\"><strong>@stri_kt<\/strong><\/a> on Twitter for updates and release notifications.<\/li>\n<\/ul>\n<p>When submitting a pull request, please add yourself to the contributors section in <a href=\"https://github.com/robfletcher/strikt/blob/master/site/src/orchid/resources/data.yml\">this yaml file<\/a> so that you get proper credit in the project documentation.<\/p>\n<h2 id=\"acknowledgments\">Acknowledgments<\/h2>\n<p>Strikt owes a lot to <a href=\"https://joel-costigliola.github.io/assertj/\">AssertJ<\/a>.\nIt's a really good library if you want to write tests in Java!<\/p>\n"
      }]
    },
    "changelog": {
      "ownKey": "changelog",
      "ownPages": [{
        "reference": {
          "path": "",
          "baseUrl": "https://strikt.io",
          "fileName": "changelog",
          "extension": "html",
          "usePrettyUrl": true,
          "link": "https://strikt.io/changelog"
        },
        "description": "",
        "title": "Changelog",
        "content": ""
      }]
    }
  },
  "ownPages": [
    {
      "reference": {
        "path": "",
        "baseUrl": "https://strikt.io",
        "fileName": "",
        "extension": "html",
        "usePrettyUrl": true,
        "link": "https://strikt.io"
      },
      "description": "",
      "title": "Strikt",
      "content": "\n<section class=\"columns is-centered\">\n  <div class=\"column is-half\">\n    <figure class=\"image\">\n      <img src=\"https://strikt.io/assets/images/logo.png\" alt=\"Strikt logo\">\n    <\/figure>\n  <\/div>\n<\/section>\n\n<section class=\"columns is-centered\">\n  <div class=\"column is-8\">\n    <div class=\"content is-medium\">\n      <p>\n        Strikt is an assertion library for Kotlin intended for use with a test runner such as <a\n        href=\"https://junit.org/junit5/\">JUnit<\/a> or <a href=\"http://spekframework.org/\">Spek<\/a>.\n      <\/p>\n      <p>Strikt gives you\u2026<\/p>\n    <\/div>\n  <\/div>\n<\/section>\n\n<section class=\"columns is-multiline is-gapless\">\n  <header class=\"column is-4 has-text-right-tablet\">\n    <div class=\"notification content is-medium\">\n      <h2 class=\"title is-4\">A powerful fluent API<\/h2>\n    <\/div>\n  <\/header>\n  <div class=\"column is-8 is-hidden-mobile\">\n    <div class=\"notification is-dark\"><\/div>\n  <\/div>\n\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Type-safe fluent assertions<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject = &quot;The Enlightened take things Lightly&quot;\nexpectThat(subject)\n  .hasLength(35)\n  .matches(Regex(&quot;[\\\\w\\\\s]+&quot;))\n  .startsWith(&quot;T&quot;)<\/code><\/pre>\n    <\/div>\n  \n\n<\/section>\n\n\n<section class=\"columns is-multiline is-gapless\">\n  <header class=\"column is-4 has-text-right-tablet\">\n    <div class=\"notification content is-medium\">\n      <h2 class=\"title is-4\">Collection handling<\/h2>\n    <\/div>\n  <\/header>\n  <div class=\"column is-8 is-hidden-mobile\">\n    <div class=\"notification is-dark\"><\/div>\n  <\/div>\n\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Flexible assertions about collections<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject = listOf(&quot;Eris&quot;, &quot;Thor&quot;, &quot;Anubis&quot;, &quot;Ra&quot;)\nexpectThat(subject)\n  .contains(&quot;Eris&quot;, &quot;Thor&quot;, &quot;Anubis&quot;)<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>\u201cNarrow\u201d the assertion to elements or ranges<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">expectThat(subject)[0].isEqualTo(&quot;Eris&quot;)<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Make grouping assertions<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject = Deity.values().map { it.toString() }\nexpectThat(subject)\n  .isNotEmpty()\n  .any { startsWith(&quot;E&quot;) }<\/code><\/pre>\n    <\/div>\n  \n\n<\/section>\n\n\n<section class=\"columns is-multiline is-gapless\">\n  <header class=\"column is-4 has-text-right-tablet\">\n    <div class=\"notification content is-medium\">\n      <h2 class=\"title is-4\">\u201cSoft\u201d assertions<\/h2>\n    <\/div>\n  <\/header>\n  <div class=\"column is-8 is-hidden-mobile\">\n    <div class=\"notification is-dark\"><\/div>\n  <\/div>\n\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Use lambdas to execute multiple assertions on a subject at once\u2026<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject = &quot;The Enlightened take things Lightly&quot;\nexpectThat(subject) {\n  hasLength(5)           // fails\n  matches(Regex(&quot;\\\\d+&quot;)) // fails\n  startsWith(&quot;T&quot;)        // still evaluated and passes\n}<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>\u2026with structured diagnostics of those that fail<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-text\">▼ Expect that &quot;The Enlightened take things Lightly&quot;:\n  ✗ has length 5 : found 35\n  ✗ matches the regular expression /\\d+/ : found &quot;The Enlightened take things Lightly&quot;\n  ✓ starts with &quot;T&quot;<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Use lambdas to execute assertions on multiple subjects at once\u2026<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val person1 = Person(name = &quot;David&quot;)\nval person2 = Person(name = &quot;Ziggy&quot;)\nexpect {\n  that(person1.name).isEqualTo(&quot;David&quot;)\n  that(person2.name).isEqualTo(&quot;Ziggy&quot;)\n}<\/code><\/pre>\n    <\/div>\n  \n\n<\/section>\n\n\n<section class=\"columns is-multiline is-gapless\">\n  <header class=\"column is-4 has-text-right-tablet\">\n    <div class=\"notification content is-medium\">\n      <h2 class=\"title is-4\">Strong typing<\/h2>\n    <\/div>\n  <\/header>\n  <div class=\"column is-8 is-hidden-mobile\">\n    <div class=\"notification is-dark\"><\/div>\n  <\/div>\n\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Assertion functions can &quot;narrow&quot; the type of the assertion<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject: Any? = &quot;The Enlightened take things Lightly&quot;\nexpectThat(subject) // type: Assertion&lt;Any?&gt;\n  .isNotNull()      // type: Assertion&lt;Any&gt;\n  .isA&lt;String&gt;()    // type: Assertion&lt;String&gt;\n  .matches(Regex(&quot;[\\\\w\\\\s]+&quot;))\n// only available on Assertion&lt;CharSequence&gt;<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Assertions can &quot;map&quot; to properties and method results in a type safe way:<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val subject = Pantheon.NORSE\nexpectThat(subject)\n  .get(Pantheon::ruler) // reference to a property\n  .get { toString() }   // return type of a method call\n  .isEqualTo(&quot;Odin&quot;)<\/code><\/pre>\n    <\/div>\n  \n\n<\/section>\n\n\n<section class=\"columns is-multiline is-gapless\">\n  <header class=\"column is-4 has-text-right-tablet\">\n    <div class=\"notification content is-medium\">\n      <h2 class=\"title is-4\">Extensibility<\/h2>\n    <\/div>\n  <\/header>\n  <div class=\"column is-8 is-hidden-mobile\">\n    <div class=\"notification is-dark\"><\/div>\n  <\/div>\n\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Custom assertions are extension functions<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">fun Assertion.Builder&lt;LocalDate&gt;.isStTibsDay() =\n  assert(&quot;is St. Tib&#39;s Day&quot;) {\n    when (MonthDay.from(it)) {\n      MonthDay.of(2, 29) -&gt; pass()\n      else -&gt; fail()\n    }\n  }\nexpectThat(LocalDate.of(2020, 2, 29)).isStTibsDay()<\/code><\/pre>\n    <\/div>\n  \n    <div class=\"column is-4 has-text-right-tablet\">\n      <div class=\"notification content is-medium\">\n      <p>Custom mappings are extension properties<\/p>\n\n      <\/div>\n    <\/div>\n    <div class=\"column is-8\">\n      <pre class=\"notification content is-medium is-dark\"><code class=\"language-kotlin\">val Assertion.Builder&lt;Pantheon&gt;.realm: Assertion.Builder&lt;String&gt;\n  get() = get { &quot;$ruler to $underworldRuler&quot; }\n\n  val subject = Pantheon.NORSE\n  expectThat(subject)\n    .realm\n    .isEqualTo(&quot;Odin to Hel&quot;)<\/code><\/pre>\n    <\/div>\n  \n\n<\/section>\n\n"
    },
    {
      "reference": {
        "path": "",
        "baseUrl": "https://strikt.io",
        "fileName": "404",
        "extension": "html",
        "usePrettyUrl": false,
        "link": "https://strikt.io/404.html"
      },
      "description": "",
      "title": "Strikt",
      "content": ""
    },
    {
      "reference": {
        "path": "",
        "baseUrl": "https://strikt.io",
        "fileName": "CNAME",
        "extension": "",
        "usePrettyUrl": false,
        "link": "https://strikt.io/CNAME"
      },
      "description": "",
      "title": "CNAME",
      "content": "strikt.io\n"
    }
  ]
}